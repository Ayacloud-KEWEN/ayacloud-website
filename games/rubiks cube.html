<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 魔方还原助手 - 完整算法版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    
    <script src="rubikSolver.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .pointer-events-auto { pointer-events: auto; }

        .glass-panel {
            background: rgba(30, 30, 35, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
        }

        .color-btn {
            width: 40px; height: 40px; border-radius: 50%;
            border: 3px solid transparent; transition: transform 0.2s, border-color 0.2s; cursor: pointer;
        }
        .color-btn.active { transform: scale(1.2); border-color: white; box-shadow: 0 0 12px rgba(255,255,255,0.6); }

        .control-btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: white; transition: all 0.2s;
        }
        .control-btn:hover:not(:disabled) { background: rgba(255, 255, 255, 0.2); transform: translateY(-2px); }
        .control-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        #msg-box { opacity: 0; transition: opacity 0.3s, transform 0.3s; transform: translateY(-20px); }
        #msg-box.show { opacity: 1; transform: translateY(20px); }
        
        /* Debug String Output */
        #debug-string {
            font-family: monospace; font-size: 10px; color: #666; 
            word-break: break-all; margin-top: 5px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="p-4 flex justify-between items-start pointer-events-auto">
            <div class="glass-panel p-5 rounded-xl text-white max-w-md w-full sm:w-auto">
                <h1 class="text-xl font-bold mb-2 flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-indigo-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                    </svg>
                    魔方还原助手
                </h1>
                <div class="text-sm text-gray-300 space-y-1">
                    <p>1. <span class="text-indigo-300">填色</span>：录入真实魔方状态。</p>
                    <p>2. <span class="text-indigo-300">求解</span>：程序将读取状态并计算。</p>
                </div>
                <div id="debug-string" class="hidden sm:block">初始化中...</div>
                <div class="mt-3 flex gap-2">
                    <button onclick="app.resetCamera()" class="text-xs bg-gray-700 hover:bg-gray-600 px-3 py-1.5 rounded text-white transition">重置视角</button>
                    <button onclick="app.resetCube()" class="text-xs bg-red-900/50 hover:bg-red-800 px-3 py-1.5 rounded text-white transition border border-red-800">重置魔方</button>
                </div>
            </div>
        </div>

        <div class="flex flex-col items-center justify-start mt-20 pointer-events-none h-full absolute w-full top-0 left-0">
            <div id="msg-box" class="glass-panel px-6 py-3 rounded-full text-white font-bold text-lg shadow-xl mb-4">就绪</div>

            <div id="step-display" class="hidden glass-panel px-8 py-4 rounded-2xl flex-col items-center animate-fade-in">
                <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">当前步骤</div>
                <div class="text-4xl font-black text-white mb-2" id="current-move-text">R</div>
                <div class="w-full bg-gray-700 rounded-full h-1.5 mb-2">
                    <div id="progress-bar" class="bg-indigo-500 h-1.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div class="text-xs text-gray-400">步骤 <span id="step-counter">0/0</span></div>
            </div>
        </div>

        <div class="p-6 w-full flex flex-col items-center gap-4 pointer-events-auto bg-gradient-to-t from-black/90 via-black/50 to-transparent pt-12">
            
            <div id="edit-controls" class="flex flex-col items-center w-full max-w-lg gap-4 transition-all duration-300">
                <div class="flex gap-3 sm:gap-4 bg-black/40 p-3 rounded-2xl backdrop-blur-md border border-white/10">
                    <div class="color-btn bg-white active" onclick="app.selectColor('U')" title="顶 (U) - 白色"></div>
                    <div class="color-btn bg-yellow-400" onclick="app.selectColor('D')" title="底 (D) - 黄色"></div>
                    <div class="color-btn bg-green-600" onclick="app.selectColor('F')" title="前 (F) - 绿色"></div>
                    <div class="color-btn bg-blue-600" onclick="app.selectColor('B')" title="后 (B) - 蓝色"></div>
                    <div class="color-btn bg-red-600" onclick="app.selectColor('R')" title="右 (R) - 红色"></div>
                    <div class="color-btn bg-orange-500" onclick="app.selectColor('L')" title="左 (L) - 橙色"></div>
                </div>

                <div class="flex gap-3 w-full">
                    <button onclick="app.scramble()" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white py-3 rounded-xl font-bold transition shadow-lg border border-gray-600 flex justify-center items-center gap-2">
                        随机打乱
                    </button>
                    <button onclick="app.startSolveMode()" id="btn-solve-action" class="flex-1 bg-indigo-600 hover:bg-indigo-500 text-white py-3 rounded-xl font-bold transition shadow-lg shadow-indigo-900/50 border border-indigo-400 flex justify-center items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" /></svg>
                        计算求解
                    </button>
                </div>
            </div>

            <div id="solve-controls" class="hidden w-full max-w-lg transition-all duration-300">
                <div class="glass-panel p-2 rounded-2xl flex justify-between items-center gap-2">
                    <button onclick="app.prevStep()" id="btn-prev" class="control-btn p-4 rounded-xl flex-1 flex justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7" /></svg>
                    </button>
                    <button onclick="app.toggleAutoPlay()" id="btn-play" class="control-btn p-4 rounded-xl flex-[2] bg-indigo-600 hover:bg-indigo-500 border-indigo-400 flex justify-center gap-2 items-center font-bold">
                        <span id="play-text">播放</span>
                        <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    </button>
                    <button onclick="app.nextStep()" id="btn-next" class="control-btn p-4 rounded-xl flex-1 flex justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7" /></svg>
                    </button>
                </div>
                <button onclick="app.exitSolveMode()" class="w-full mt-3 text-gray-400 text-sm hover:text-white py-2">
                    退出还原模式
                </button>
            </div>
        </div>
    </div>

<script>
/**
 * 3D Rubik's Cube with Algorithm Interface
 */

class RubiksApp {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.cubies = []; 
        this.isAnimating = false;
        
        // State
        this.solutionQueue = []; 
        this.currentStepIndex = -1; 
        this.isPlaying = false;
        this.playInterval = null;
        this.isSolverReady = false;

        // Color Definitions (Standard Scheme)
        this.colors = {
            'U': 0xffffff, // White
            'D': 0xffd500, // Yellow
            'F': 0x009e60, // Green
            'B': 0x0051ba, // Blue
            'R': 0xc41e3a, // Red
            'L': 0xff5800, // Orange
            'Core': 0x111111 // Black
        };

        // Reverse lookup for reading state
        this.hexToChar = {
            0xffffff: 'U', 0xffd500: 'D', 0x009e60: 'F',
            0x0051ba: 'B', 0xc41e3a: 'R', 0xff5800: 'L'
        };
        
        this.selectedColor = 'U';
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();

        this.axes = {
            'x': new THREE.Vector3(1, 0, 0),
            'y': new THREE.Vector3(0, 1, 0),
            'z': new THREE.Vector3(0, 0, 1)
        };

        this.init();
        this.initSolverLib();
    }

    init() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a1a1a);
        
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        this.camera.position.set(6, 5, 8);
        this.camera.lookAt(0, 0, 0);

        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        this.scene.add(dirLight);
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
        backLight.position.set(-10, -10, -10);
        this.scene.add(backLight);

        this.createCube();

        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enablePan = false;

        window.addEventListener('resize', () => this.onWindowResize());
        this.renderer.domElement.addEventListener('pointerdown', (e) => this.onCanvasClick(e));

        this.animate();
    }

    initSolverLib() {
        // Initialize min2phase.js solver in background
        setTimeout(() => {
            if (typeof min2phase !== 'undefined') {
                document.getElementById('debug-string').innerText = "算法库初始化中...";
                document.getElementById('btn-solve-action').disabled = true;
                
                try {
                    // min2phase initialization usually happens automatically or via init()
                    min2phase.init(); 
                    this.isSolverReady = true;
                    document.getElementById('debug-string').innerText = "算法库就绪";
                    document.getElementById('btn-solve-action').disabled = false;
                } catch(e) {
                    console.error("Solver Init Error:", e);
                    document.getElementById('debug-string').innerText = "算法库初始化失败";
                    // Even if failed, enable button to allow fallback
                    document.getElementById('btn-solve-action').disabled = false;
                }
            } else {
                document.getElementById('debug-string').innerText = "提示: 算法库未连接 (使用简易模式)";
                console.warn("min2phase library missing. Fallback mode enabled.");
                document.getElementById('btn-solve-action').disabled = false;
            }
        }, 1000);
    }

    createCube() {
        this.cubies.forEach(c => this.scene.remove(c));
        this.cubies = [];
        const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
        
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    // Materials Order: R, L, U, D, F, B
                    const materials = [
                        new THREE.MeshStandardMaterial({ color: x === 1 ? this.colors['R'] : this.colors['Core'] }),
                        new THREE.MeshStandardMaterial({ color: x === -1 ? this.colors['L'] : this.colors['Core'] }),
                        new THREE.MeshStandardMaterial({ color: y === 1 ? this.colors['U'] : this.colors['Core'] }),
                        new THREE.MeshStandardMaterial({ color: y === -1 ? this.colors['D'] : this.colors['Core'] }),
                        new THREE.MeshStandardMaterial({ color: z === 1 ? this.colors['F'] : this.colors['Core'] }),
                        new THREE.MeshStandardMaterial({ color: z === -1 ? this.colors['B'] : this.colors['Core'] }),
                    ];
                    const mesh = new THREE.Mesh(geometry, materials);
                    mesh.position.set(x, y, z);
                    this.cubies.push(mesh);
                    this.scene.add(mesh);
                }
            }
        }
    }

    resetCube() {
        this.solutionQueue = [];
        this.currentStepIndex = -1;
        this.createCube();
        this.showMessage("魔方已重置");
        this.exitSolveMode();
        document.getElementById('debug-string').innerText = this.isSolverReady ? "算法库就绪" : "等待...";
    }
    
    exitSolveMode() {
        this.stopAutoPlay();
        document.getElementById('edit-controls').classList.remove('hidden');
        document.getElementById('edit-controls').classList.add('flex');
        document.getElementById('solve-controls').classList.add('hidden');
        document.getElementById('step-display').classList.add('hidden');
        document.getElementById('step-display').classList.remove('flex');
        this.currentStepIndex = -1;
        this.solutionQueue = [];
        this.showMessage("退出还原模式");
    }

    // --- Interaction ---

    onCanvasClick(event) {
        if (this.isAnimating || this.isPlaying) return;
        const solveControls = document.getElementById('solve-controls');
        if (!solveControls.classList.contains('hidden')) {
            this.showMessage("还原模式下不可修改颜色", 1000);
            return;
        }

        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.cubies);

        if (intersects.length > 0) {
            const intersect = intersects[0];
            const materialIndex = intersect.face.materialIndex;
            this.highlightFace(intersect.object);
            intersect.object.material[materialIndex].color.setHex(this.colors[this.selectedColor]);
        }
    }

    selectColor(code) {
        this.selectedColor = code;
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('onclick').includes(`'${code}'`)) {
                btn.classList.add('active');
            }
        });
    }

    // --- 核心功能：读取状态并求解 ---

getCubeStateString() {
    const FACE_ORDER = ["U", "R", "F", "D", "L", "B"];

    // min2phase 的固定面朝向定义
    const faceConfig = {
        U: { axis: "y", val: 1,  stickerIndex: (x, z) => (1 - z) * 3 + (x + 1) },
        D: { axis: "y", val: -1, stickerIndex: (x, z) => (z + 1) * 3 + (x + 1) },
        F: { axis: "z", val: 1,  stickerIndex: (x, y) => (1 - y) * 3 + (x + 1) },
        B: { axis: "z", val: -1, stickerIndex: (x, y) => (1 - y) * 3 + (1 - x) },
        R: { axis: "x", val: 1,  stickerIndex: (z, y) => (1 - y) * 3 + (1 - z) },
        L: { axis: "x", val: -1, stickerIndex: (z, y) => (1 - y) * 3 + (z + 1) },
    };

    let result = "";

    for (let face of FACE_ORDER) {

        let config = faceConfig[face];
        let stickers = Array(9).fill("?");

        this.cubies.forEach(cubie => {

            const pos = cubie.position;
            if (Math.abs(pos[config.axis] - config.val) < 0.1) {

                let x = Math.round(pos.x);
                let y = Math.round(pos.y);
                let z = Math.round(pos.z);

                let matIndex = {
                    U: 2,
                    R: 0,
                    F: 4,
                    D: 3,
                    L: 1,
                    B: 5
                }[face];

                const hex = cubie.material[matIndex].color.getHex();
                const char = this.hexToChar[hex] || "?";

                // 每个面的坐标映射到 0~8
                let index;
                if (face === "U" || face === "D")
                    index = config.stickerIndex(x, z);
                else if (face === "F" || face === "B")
                    index = config.stickerIndex(x, y);
                else if (face === "R" || face === "L")
                    index = config.stickerIndex(z, y);

                stickers[index] = char;
            }
        });

        result += stickers.join("");
    }

    return result;
}


    async startSolveMode() {
        const stateString = this.getCubeStateString();
        console.log("Detected State:", stateString);
        
        if (stateString.includes('?')) {
            alert("检测到未填色的块，请检查魔方！");
            return;
        }

        this.showMessage("正在计算...", 0);

        setTimeout(async () => {
            try {
                const solution = await this.solveWithAlgorithm(stateString);
                
                if (!solution) return;

                this.parseSolution(solution);
                
                document.getElementById('edit-controls').classList.add('hidden');
                document.getElementById('edit-controls').classList.remove('flex');
                document.getElementById('solve-controls').classList.remove('hidden');
                document.getElementById('step-display').classList.remove('hidden');
                document.getElementById('step-display').classList.add('flex');
                this.updateStepUI();
                this.showMessage("计算完成！");

            } catch (e) {
                console.error(e);
                let errMsg = "无法求解。\n\n可能原因：\n1. 颜色填错（如中心块重复/角块错误）。\n2. 魔方状态在物理上不可能复原。";
                if (String(e).includes("missing")) errMsg = "网络原因导致算法库未加载，且无打乱记录可回退。";
                
                alert(errMsg);
                this.showMessage("错误", 2000);
            }
        }, 100);
    }

    solveWithAlgorithm(stateString) {
        return new Promise((resolve, reject) => {
            if (stateString === "UUUUUUUUURRRRRRRRRFFFFFFFFFDDDDDDDDDLLLLLLLLLBBBBBBBBB") {
                alert("魔方已经是还原状态！");
                reject("Solved");
                return;
            }

            // Check for Library
            if (typeof min2phase === 'undefined' || !this.isSolverReady) {
                 // Fallback to scramble history
                 if (this.scrambleHistory && this.scrambleHistory.length > 0) {
                     const moves = [...this.scrambleHistory].reverse().map(m => {
                        let notation = m.face;
                        if (m.dir === 1) notation += "'";
                        return notation;
                     }).join(" ");
                     resolve(moves);
                     this.scrambleHistory = [];
                     return;
                 }
                 
                 reject("Library missing");
                 return;
            }

            // Real Solver using min2phase
            try {
                // min2phase usage: new min2phase.Search().solution(state)
                const search = new min2phase.Search();
                const solution = search.solution(stateString, 21, 100000000, 0, 0); // params: state, maxDepth, probeMax, timeOut, verbose
                
                if (solution && solution.length > 0 && !solution.startsWith("Error")) {
                    resolve(solution);
                } else {
                    reject("Solver returned error: " + solution);
                }
            } catch (err) {
                reject(err);
            }
        });
    }

    parseSolution(solStr) {
        // min2phase returns simplified string like "R2 U F' ..."
        const moves = solStr.trim().split(/\s+/);
        this.solutionQueue = moves.map(m => {
            if(!m) return null; 
            let face = m[0];
            let dir = 1;
            let power = 1;
            if (m.includes("'")) { dir = -1; power = -1; }
            if (m.includes("2")) { power = 2; }
            return { face, power, notation: m };
        }).filter(m => m !== null);
        
        this.currentStepIndex = -1;
    }

    // --- 动画与逻辑 ---

    rotateFace(face, power = 1, duration = 300) {
        return new Promise((resolve) => {
            this.isAnimating = true;
            
            const rotations = Math.abs(power);
            const dir = power > 0 ? 1 : -1;
            const singleDuration = duration / rotations;

            let count = 0;
            const run = () => {
                this._rotateSingle90(face, dir, singleDuration).then(() => {
                    count++;
                    if (count < rotations) {
                        run();
                    } else {
                        this.isAnimating = false;
                        resolve();
                    }
                });
            };
            run();
        });
    }

    _rotateSingle90(face, direction, duration) {
        return new Promise((resolve) => {
            let axis = new THREE.Vector3();
            let cubiesToRotate = [];
            const EPSILON = 0.1;

            this.cubies.forEach(cubie => {
                const pos = cubie.position;
                if (face === 'U' && Math.abs(pos.y - 1) < EPSILON) { axis = this.axes.y; cubiesToRotate.push(cubie); }
                if (face === 'D' && Math.abs(pos.y + 1) < EPSILON) { axis = this.axes.y; cubiesToRotate.push(cubie); }
                if (face === 'R' && Math.abs(pos.x - 1) < EPSILON) { axis = this.axes.x; cubiesToRotate.push(cubie); }
                if (face === 'L' && Math.abs(pos.x + 1) < EPSILON) { axis = this.axes.x; cubiesToRotate.push(cubie); }
                if (face === 'F' && Math.abs(pos.z - 1) < EPSILON) { axis = this.axes.z; cubiesToRotate.push(cubie); }
                if (face === 'B' && Math.abs(pos.z + 1) < EPSILON) { axis = this.axes.z; cubiesToRotate.push(cubie); }
            });

            let angle = (Math.PI / 2) * -direction;
            if (face === 'L' || face === 'B') angle = (Math.PI / 2) * direction; 

            const pivot = new THREE.Object3D();
            pivot.rotation.set(0,0,0);
            this.scene.add(pivot);
            cubiesToRotate.forEach(c => { this.scene.remove(c); pivot.add(c); });

            new TWEEN.Tween(pivot.rotation)
                .to({ [axis.x ? 'x' : axis.y ? 'y' : 'z']: angle }, duration)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    pivot.updateMatrixWorld();
                    cubiesToRotate.forEach(c => {
                        c.updateMatrixWorld();
                        const vector = new THREE.Vector3();
                        const quaternion = new THREE.Quaternion();
                        c.getWorldPosition(vector);
                        c.getWorldQuaternion(quaternion);
                        vector.x = Math.round(vector.x);
                        vector.y = Math.round(vector.y);
                        vector.z = Math.round(vector.z);
                        c.position.copy(vector);
                        c.quaternion.copy(quaternion);
                        pivot.remove(c);
                        this.scene.add(c);
                    });
                    this.scene.remove(pivot);
                    resolve();
                })
                .start();
        });
    }

    async scramble() {
        if (this.isAnimating) return;
        this.showMessage("正在打乱...");
        this.scrambleHistory = []; 
        
        const faces = ['U', 'D', 'L', 'R', 'F', 'B'];
        for (let i = 0; i < 15; i++) {
            const face = faces[Math.floor(Math.random() * faces.length)];
            const dir = Math.random() > 0.5 ? 1 : -1;
            await this.rotateFace(face, dir, 100);
            this.scrambleHistory.push({ face, dir });
        }
        this.showMessage("打乱完成");
    }

    // --- Step Logic ---

    updateStepUI() {
        const total = this.solutionQueue.length;
        const current = this.currentStepIndex + 1;
        document.getElementById('step-counter').innerText = `${current} / ${total}`;
        const pct = total === 0 ? 0 : (current / total) * 100;
        document.getElementById('progress-bar').style.width = `${pct}%`;

        if (this.currentStepIndex >= 0 && this.currentStepIndex < total) {
            document.getElementById('current-move-text').innerText = this.solutionQueue[this.currentStepIndex].notation;
        } else if (this.currentStepIndex === -1) {
            document.getElementById('current-move-text').innerText = "Ready";
        } else {
            document.getElementById('current-move-text').innerText = "Done";
        }

        document.getElementById('btn-prev').disabled = (this.currentStepIndex < 0);
        document.getElementById('btn-next').disabled = (this.currentStepIndex >= total - 1);
    }

    async nextStep() {
        if (this.isAnimating) return;
        if (this.currentStepIndex >= this.solutionQueue.length - 1) {
            this.showMessage("已完成还原！");
            this.stopAutoPlay();
            return;
        }
        const nextIdx = this.currentStepIndex + 1;
        const move = this.solutionQueue[nextIdx];
        this.currentStepIndex = nextIdx; 
        this.updateStepUI();
        await this.rotateFace(move.face, move.power, 400);
    }

    async prevStep() {
        if (this.isAnimating) return;
        if (this.currentStepIndex < 0) return;
        const move = this.solutionQueue[this.currentStepIndex];
        // Undo: Inverse power
        this.currentStepIndex--;
        this.updateStepUI();
        await this.rotateFace(move.face, -move.power, 400);
    }

    toggleAutoPlay() {
        if (this.isPlaying) this.stopAutoPlay();
        else this.startAutoPlay();
    }

    startAutoPlay() {
        if (this.currentStepIndex >= this.solutionQueue.length - 1) return;
        this.isPlaying = true;
        document.getElementById('play-text').innerText = "暂停";
        const stepLoop = async () => {
            if (!this.isPlaying) return;
            if (this.currentStepIndex >= this.solutionQueue.length - 1) {
                this.stopAutoPlay();
                return;
            }
            await this.nextStep();
            if (this.isPlaying) setTimeout(stepLoop, 200);
        };
        stepLoop();
    }

    stopAutoPlay() {
        this.isPlaying = false;
        document.getElementById('play-text').innerText = "播放";
    }

    // --- Helper ---
    showMessage(text, time = 2000) {
        const el = document.getElementById('msg-box');
        el.innerText = text;
        el.classList.add('show');
        if (this.msgTimeout) clearTimeout(this.msgTimeout);
        if (time > 0) {
            this.msgTimeout = setTimeout(() => { el.classList.remove('show'); }, time);
        }
    }
    highlightFace(mesh) {
        new TWEEN.Tween(mesh.scale).to({ x: 0.8, y: 0.8, z: 0.8 }, 50).yoyo(true).repeat(1).start();
    }
    resetCamera() {
        new TWEEN.Tween(this.camera.position).to({ x: 6, y: 5, z: 8 }, 1000).easing(TWEEN.Easing.Cubic.Out).onUpdate(() => this.camera.lookAt(0,0,0)).start();
    }
    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    animate() {
        requestAnimationFrame(() => this.animate());
        TWEEN.update();
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }
}

window.onload = () => { window.app = new RubiksApp(); };
</script>
</body>
</html>