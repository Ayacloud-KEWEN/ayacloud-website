<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 魔方还原助手 - 智能提示版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    
    <!-- ========================================== -->
    <!-- 内嵌 min2phase.js 核心算法库 -->
    <!-- ========================================== -->
    <script>
    "use strict";

    var min2phase = (function() {
        var USE_TWST_FLIP_PRUN = true;
        var PARTIAL_INIT_LEVEL = 2;

        var MAX_PRE_MOVES = 20;
        var TRY_INVERSE = true;
        var TRY_THREE_AXES = true;

        var USE_CONJ_PRUN = USE_TWST_FLIP_PRUN;
        var MIN_P1LENGTH_PRE = 7;
        var MAX_DEPTH2 = 13;

        var INVERSE_SOLUTION = 0x2;

        function Search() {
            this.move = [];
            this.moveSol = [];

            this.nodeUD = [];

            this.valid1 = 0;
            this.allowShorter = false;
            this.cc = new CubieCube();
            this.urfCubieCube = [];
            this.urfCoordCube = [];
            this.phase1Cubie = [];

            this.preMoveCubes = [];
            this.preMoves = [];
            this.preMoveLen = 0;
            this.maxPreMoves = 0;

            this.isRec = false;
            for (var i = 0; i < 21; i++) {
                this.nodeUD[i] = new CoordCube();
                this.phase1Cubie[i] = new CubieCube();
            }
            for (var i = 0; i < 6; i++) {
                this.urfCubieCube[i] = new CubieCube();
                this.urfCoordCube[i] = new CoordCube();
            }
            for (var i = 0; i < MAX_PRE_MOVES; i++) {
                this.preMoveCubes[i + 1] = new CubieCube();
            }
        }

        var Ux1 = 0;
        var Ux2 = 1;
        var Ux3 = 2;
        var Rx1 = 3;
        var Rx2 = 4;
        var Rx3 = 5;
        var Fx1 = 6;
        var Fx2 = 7;
        var Fx3 = 8;
        var Dx1 = 9;
        var Dx2 = 10;
        var Dx3 = 11;
        var Lx1 = 12;
        var Lx2 = 13;
        var Lx3 = 14;
        var Bx1 = 15;
        var Bx2 = 16;
        var Bx3 = 17;

        var N_MOVES = 18;
        var N_MOVES2 = 10;
        var N_FLIP = 2048;
        var N_FLIP_SYM = 336;
        var N_TWST = 2187;
        var N_TWST_SYM = 324;
        var N_PERM = 40320;
        var N_PERM_SYM = 2768;
        var N_MPERM = 24;
        var N_SLICE = 495;
        var N_COMB = 140;

        var SYM_E2C_MAGIC = 0x00DDDD00;
        var Cnk = [];
        var fact = [1];
        var move2str = [
            "U ", "U2", "U'", "R ", "R2", "R'", "F ", "F2", "F'",
            "D ", "D2", "D'", "L ", "L2", "L'", "B ", "B2", "B'"
        ];
        var ud2std = [Ux1, Ux2, Ux3, Rx2, Fx2, Dx1, Dx2, Dx3, Lx2, Bx2, Rx1, Rx3, Fx1, Fx3, Lx1, Lx3, Bx1, Bx3];
        var std2ud = [];
        var ckmv2bit = [];
        var urfMove = [
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
            [6, 7, 8, 0, 1, 2, 3, 4, 5, 15, 16, 17, 9, 10, 11, 12, 13, 14],
            [3, 4, 5, 6, 7, 8, 0, 1, 2, 12, 13, 14, 15, 16, 17, 9, 10, 11],
            [2, 1, 0, 5, 4, 3, 8, 7, 6, 11, 10, 9, 14, 13, 12, 17, 16, 15],
            [8, 7, 6, 2, 1, 0, 5, 4, 3, 17, 16, 15, 11, 10, 9, 14, 13, 12],
            [5, 4, 3, 8, 7, 6, 2, 1, 0, 14, 13, 12, 17, 16, 15, 11, 10, 9]
        ];

        { // init util
            for (var i = 0; i < 18; i++) {
                std2ud[ud2std[i]] = i;
            }
            for (var i = 0; i < 10; i++) {
                var ix = ~~(ud2std[i] / 3);
                ckmv2bit[i] = 0;
                for (var j = 0; j < 10; j++) {
                    var jx = ~~(ud2std[j] / 3);
                    ckmv2bit[i] |= ((ix == jx) || ((ix % 3 == jx % 3) && (ix >= jx)) ? 1 : 0) << j;
                }
            }
            ckmv2bit[10] = 0;
            for (var i = 0; i < 13; i++) {
                Cnk[i] = [];
                fact[i + 1] = fact[i] * (i + 1);
                Cnk[i][0] = Cnk[i][i] = 1;
                for (var j = 1; j < 13; j++) {
                    Cnk[i][j] = j <= i ? Cnk[i - 1][j - 1] + Cnk[i - 1][j] : 0;
                }
            }
        }

        function setPruning(table, index, value) {
            table[index >> 3] ^= value << (index << 2); // index << 2 <=> (index & 7) << 2
        }

        function getPruning(table, index) {
            return table[index >> 3] >> (index << 2) & 0xf; // index << 2 <=> (index & 7) << 2
        }

        function getPruningMax(maxValue, table, index) {
            return Math.min(maxValue, table[index >> 3] >> (index << 2) & 0xf);
        }

        function hasZero(val) {
            return ((val - 0x11111111) & ~val & 0x88888888) != 0;
        }

        function ESym2CSym(idx) {
            return idx ^ (SYM_E2C_MAGIC >> ((idx & 0xf) << 1) & 3);
        }

        function getPermSymInv(idx, sym, isCorner) {
            var idxi = PermInvEdgeSym[idx];
            if (isCorner) {
                idxi = ESym2CSym(idxi);
            }
            return idxi & 0xfff0 | SymMult[idxi & 0xf][sym];
        }

        function CubieCube() {
            this.ca = [0, 1, 2, 3, 4, 5, 6, 7];
            this.ea = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
        }

        function setNPerm(arr, idx, n) {
            n--;
            var val = 0x76543210;
            for (var i = 0; i < n; ++i) {
                var p = fact[n - i];
                var v = ~~(idx / p);
                idx %= p;
                v <<= 2;
                arr[i] = arr[i] & 0xf0 | val >> v & 0xf;
                var m = (1 << v) - 1;
                val = (val & m) + (val >> 4 & ~m);
            }
            arr[n] = arr[n] & 0xf0 | val & 0xf;
        }

        function getNPerm(arr, n) {
            var idx = 0,
                val = 0x76543210;
            for (var i = 0; i < n - 1; ++i) {
                var v = (arr[i] & 0xf) << 2;
                idx = (n - i) * idx + (val >> v & 0xf);
                val -= 0x11111110 << v;
            }
            return idx;
        }

        function setNPermFull(arr, idx, n) {
            arr[n - 1] = arr[n - 1] & 0xf0;
            for (var i = n - 2; i >= 0; --i) {
                arr[i] = arr[i] & 0xf0 | idx % (n - i);
                idx = ~~(idx / (n - i));
                for (var j = i + 1; j < n; ++j) {
                    if ((arr[j] & 0xf) >= (arr[i] & 0xf)) {
                        arr[j] += 1;
                    }
                }
            }
        }

        function getNPermFull(arr, n) {
            var idx = 0;
            for (var i = 0; i < n; ++i) {
                idx *= n - i;
                for (var j = i + 1; j < n; ++j) {
                    if ((arr[j] & 0xf) < (arr[i] & 0xf)) {
                        ++idx;
                    }
                }
            }
            return idx;
        }

        function getComb(arr, mask) {
            var end = arr.length - 1;
            var idxC = 0,
                r = 4;
            for (var i = end; i >= 0; i--) {
                var perm = arr[i] & 0xf;
                if ((perm & 0xc) == mask) {
                    idxC += Cnk[i][r--];
                }
            }
            return idxC;
        }

        function setComb(arr, idxC, mask) {
            var end = arr.length - 1;
            var r = 4,
                fill = end;
            for (var i = end; i >= 0; i--) {
                if (idxC >= Cnk[i][r]) {
                    idxC -= Cnk[i][r--];
                    arr[i] = arr[i] & 0xf0 | r | mask;
                } else {
                    if ((fill & 0xc) == mask) {
                        fill -= 4;
                    }
                    arr[i] = arr[i] & 0xf0 | fill--;
                }
            }
        }

        function getNParity(idx, n) {
            var p = 0;
            for (var i = n - 2; i >= 0; i--) {
                p ^= idx % (n - i);
                idx = ~~(idx / (n - i));
            }
            return p & 1;
        }
        CubieCube.EdgeMult = function(a, b, prod) {
            for (var ed = 0; ed < 12; ed++) {
                prod.ea[ed] = a.ea[b.ea[ed] & 0xf] ^ (b.ea[ed] & 0x10);
            }
        }
        CubieCube.CornMult = function(a, b, prod) {
            for (var corn = 0; corn < 8; corn++) {
                var ori = ((a.ca[b.ca[corn] & 0xf] >> 4) + (b.ca[corn] >> 4)) % 3;
                prod.ca[corn] = a.ca[b.ca[corn] & 0xf] & 0xf | ori << 4;
            }
        }
        CubieCube.CornMultFull = function(a, b, prod) {
            for (var corn = 0; corn < 8; corn++) {
                var oriA = a.ca[b.ca[corn] & 0xf] >> 4;
                var oriB = b.ca[corn] >> 4;
                var ori = oriA + ((oriA < 3) ? oriB : 6 - oriB);
                ori = ori % 3 + ((oriA < 3) == (oriB < 3) ? 0 : 3);
                prod.ca[corn] = a.ca[b.ca[corn] & 0xf] & 0xf | ori << 4;
            }
        }
        CubieCube.CornConjugate = function(a, idx, b) {
            var sinv = SymCube[SymMultInv[0][idx]];
            var s = SymCube[idx];
            for (var corn = 0; corn < 8; corn++) {
                var oriA = sinv.ca[a.ca[s.ca[corn] & 0xf] & 0xf] >> 4;
                var oriB = a.ca[s.ca[corn] & 0xf] >> 4;
                var ori = (oriA < 3) ? oriB : (3 - oriB) % 3;
                b.ca[corn] = sinv.ca[a.ca[s.ca[corn] & 0xf] & 0xf] & 0xf | ori << 4;
            }
        }
        CubieCube.EdgeConjugate = function(a, idx, b) {
            var sinv = SymCube[SymMultInv[0][idx]];
            var s = SymCube[idx];
            for (var ed = 0; ed < 12; ed++) {
                b.ea[ed] = sinv.ea[a.ea[s.ea[ed] & 0xf] & 0xf] ^ (a.ea[s.ea[ed] & 0xf] & 0x10) ^ (s.ea[ed] & 0x10);
            }
        }
        CubieCube.prototype.init = function(ca, ea) {
            this.ca = ca.slice();
            this.ea = ea.slice();
            return this;
        }
        CubieCube.prototype.initCoord = function(cperm, twst, eperm, flip) {
            setNPerm(this.ca, cperm, 8);
            this.setTwst(twst);
            setNPermFull(this.ea, eperm, 12);
            this.setFlip(flip);
            return this;
        }
        CubieCube.prototype.isEqual = function(c) {
            for (var i = 0; i < 8; i++) {
                if (this.ca[i] != c.ca[i]) {
                    return false;
                }
            }
            for (var i = 0; i < 12; i++) {
                if (this.ea[i] != c.ea[i]) {
                    return false;
                }
            }
            return true;
        }
        CubieCube.prototype.setFlip = function(idx) {
            var parity = 0;
            for (var i = 10; i >= 0; i--, idx >>= 1) {
                this.ea[i] = this.ea[i] & 0xf | (idx & 1) << 4;
                parity ^= this.ea[i];
            }
            this.ea[11] = this.ea[11] & 0xf | parity & 0x10;
        }
        CubieCube.prototype.getFlip = function() {
            var idx = 0;
            for (var i = 0; i < 11; i++) {
                idx = idx << 1 | this.ea[i] >> 4 & 1;
            }
            return idx;
        }
        CubieCube.prototype.getFlipSym = function() {
            return FlipR2S[this.getFlip()];
        }
        CubieCube.prototype.setTwst = function(idx) {
            var twst = 15;
            for (var i = 6; i >= 0; i--, idx = ~~(idx / 3)) {
                this.ca[i] = this.ca[i] & 0xf | idx % 3 << 4;
                twst -= this.ca[i] >> 4;
            }
            this.ca[7] = this.ca[7] & 0xf | (twst % 3) << 4;
        }
        CubieCube.prototype.getTwst = function() {
            var idx = 0;
            for (var i = 0; i < 7; i++) {
                idx += (idx << 1) + (this.ca[i] >> 4);
            }
            return idx;
        }
        CubieCube.prototype.getTwstSym = function() {
            return TwstR2S[this.getTwst()];
        }
        CubieCube.prototype.setCPerm = function(idx) {
            setNPerm(this.ca, idx, 8);
        }
        CubieCube.prototype.getCPerm = function() {
            return getNPerm(this.ca, 8);
        }
        CubieCube.prototype.getCPermSym = function() {
            return ESym2CSym(EPermR2S[getNPerm(this.ca, 8)]);
        }
        CubieCube.prototype.setEPerm = function(idx) {
            setNPerm(this.ea, idx, 8);
        }
        CubieCube.prototype.getEPerm = function() {
            return getNPerm(this.ea, 8);
        }
        CubieCube.prototype.getEPermSym = function() {
            return EPermR2S[getNPerm(this.ea, 8)];
        }
        CubieCube.prototype.getSlice = function() {
            return 494 - getComb(this.ea, 8);
        }
        CubieCube.prototype.setSlice = function(idx) {
            setComb(this.ea, 494 - idx, 8);
        }
        CubieCube.prototype.getMPerm = function() {
            return getNPermFull(this.ea, 12) % 24;
        }
        CubieCube.prototype.setMPerm = function(idx) {
            setNPermFull(this.ea, idx, 12);
        }
        CubieCube.prototype.getCComb = function() {
            return getComb(this.ca, 0);
        }
        CubieCube.prototype.setCComb = function(idx) {
            setComb(this.ca, idx, 0);
        }
        CubieCube.prototype.URFConjugate = function() {
            var temps = new CubieCube();
            CubieCube.CornMult(CubieCube.urf2, this, temps);
            CubieCube.CornMult(temps, CubieCube.urf1, this);
            CubieCube.EdgeMult(CubieCube.urf2, this, temps);
            CubieCube.EdgeMult(temps, CubieCube.urf1, this);
        }
        var cornerFacelet = [
            [8, 9, 20],
            [6, 18, 38],
            [0, 36, 47],
            [2, 45, 11],
            [29, 26, 15],
            [27, 44, 24],
            [33, 53, 42],
            [35, 17, 51]
        ];
        var edgeFacelet = [
            [5, 10],
            [7, 19],
            [3, 37],
            [1, 46],
            [32, 16],
            [28, 25],
            [30, 43],
            [34, 52],
            [23, 12],
            [21, 41],
            [50, 39],
            [48, 14]
        ];
        CubieCube.prototype.toFaceCube = function(cFacelet, eFacelet) {
            cFacelet = cFacelet || cornerFacelet;
            eFacelet = eFacelet || edgeFacelet;
            var ts = "URFDLB";
            var f = [];
            for (var i = 0; i < 54; i++) {
                f[i] = ts[~~(i / 9)];
            }
            for (var c = 0; c < 8; c++) {
                var j = this.ca[c] & 0xf; // cornercubie with index j is at
                var ori = this.ca[c] >> 4; // Orientation of this cubie
                for (var n = 0; n < 3; n++)
                    f[cFacelet[c][(n + ori) % 3]] = ts[~~(cFacelet[j][n] / 9)];
            }
            for (var e = 0; e < 12; e++) {
                var j = this.ea[e] & 0xf; // edgecubie with index j is at edgeposition
                var ori = this.ea[e] >> 4; // Orientation of this cubie
                for (var n = 0; n < 2; n++)
                    f[eFacelet[e][(n + ori) % 2]] = ts[~~(eFacelet[j][n] / 9)];
            }
            return f.join("");
        }
        CubieCube.prototype.invFrom = function(cc) {
            for (var edge = 0; edge < 12; edge++) {
                this.ea[cc.ea[edge] & 0xf] = edge & 0xf | cc.ea[edge] & 0x10;
            }
            for (var corn = 0; corn < 8; corn++) {
                this.ca[cc.ca[corn] & 0xf] = corn | 0x40 >> (cc.ca[corn] >> 4) & 0x30;
            }
            return this;
        }
        CubieCube.prototype.fromFacelet = function(facelet, cFacelet, eFacelet) {
            cFacelet = cFacelet || cornerFacelet;
            eFacelet = eFacelet || edgeFacelet;
            var count = 0;
            var f = [];
            var centers = facelet[4] + facelet[13] + facelet[22] + facelet[31] + facelet[40] + facelet[49];
            for (var i = 0; i < 54; ++i) {
                f[i] = centers.indexOf(facelet[i]);
                if (f[i] == -1) {
                    return -1;
                }
                count += 1 << (f[i] << 2);
            }
            if (count != 0x999999) {
                return -1;
            }
            var col1, col2, i, j, ori;
            for (i = 0; i < 8; ++i) {
                for (ori = 0; ori < 3; ++ori)
                    if (f[cFacelet[i][ori]] == 0 || f[cFacelet[i][ori]] == 3)
                        break;
                col1 = f[cFacelet[i][(ori + 1) % 3]];
                col2 = f[cFacelet[i][(ori + 2) % 3]];
                for (j = 0; j < 8; ++j) {
                    if (col1 == ~~(cFacelet[j][1] / 9) && col2 == ~~(cFacelet[j][2] / 9)) {
                        this.ca[i] = j | ori % 3 << 4;
                        break;
                    }
                }
            }
            for (i = 0; i < 12; ++i) {
                for (j = 0; j < 12; ++j) {
                    if (f[eFacelet[i][0]] == ~~(eFacelet[j][0] / 9) && f[eFacelet[i][1]] == ~~(eFacelet[j][1] / 9)) {
                        this.ea[i] = j;
                        break;
                    }
                    if (f[eFacelet[i][0]] == ~~(eFacelet[j][1] / 9) && f[eFacelet[i][1]] == ~~(eFacelet[j][0] / 9)) {
                        this.ea[i] = j | 0x10;
                        break;
                    }
                }
            }
        }

        function CoordCube() {
            this.twst = 0;
            this.flip = 0;
            this.slice = 0;
            this.prun = 0;
            this.twstc = 0;
            this.flipc = 0;
        }
        CoordCube.prototype.set = function(node) {
            this.twst = node.twst;
            this.flip = node.flip;
            this.slice = node.slice;
            this.prun = node.prun;
            if (USE_CONJ_PRUN) {
                this.twstc = node.twstc;
                this.flipc = node.flipc;
            }
        }
        CoordCube.prototype.calcPruning = function(isPhase1) {
            this.prun = Math.max(
                getPruningMax(SliceTwstPrunMax, SliceTwstPrun,
                    (this.twst >> 3) * N_SLICE + SliceConj[this.slice << 3 | this.twst & 7]),
                getPruningMax(SliceFlipPrunMax, SliceFlipPrun,
                    (this.flip >> 3) * N_SLICE + SliceConj[this.slice << 3 | this.flip & 7]),
                USE_CONJ_PRUN ? getPruningMax(TwstFlipPrunMax, TwstFlipPrun,
                    (this.twstc >> 3) << 11 | FlipS2RF[this.flipc ^ (this.twstc & 7)]) : 0,
                USE_TWST_FLIP_PRUN ? getPruningMax(TwstFlipPrunMax, TwstFlipPrun,
                    (this.twst >> 3) << 11 | FlipS2RF[this.flip ^ (this.twst & 7)]) : 0
            );
        }
        CoordCube.prototype.setWithPrun = function(cc, depth) {
            this.twst = cc.getTwstSym();
            this.flip = cc.getFlipSym();
            this.prun = USE_TWST_FLIP_PRUN ? getPruningMax(TwstFlipPrunMax, TwstFlipPrun,
                (this.twst >> 3) << 11 | FlipS2RF[this.flip ^ (this.twst & 7)]) : 0;
            if (this.prun > depth) {
                return false;
            }
            this.slice = cc.getSlice();
            this.prun = Math.max(this.prun,
                getPruningMax(SliceTwstPrunMax, SliceTwstPrun,
                    (this.twst >> 3) * N_SLICE + SliceConj[this.slice << 3 | this.twst & 7]),
                getPruningMax(SliceFlipPrunMax, SliceFlipPrun,
                    (this.flip >> 3) * N_SLICE + SliceConj[this.slice << 3 | this.flip & 7]));
            if (this.prun > depth) {
                return false;
            }
            if (USE_CONJ_PRUN) {
                var pc = new CubieCube();
                CubieCube.CornConjugate(cc, 1, pc);
                CubieCube.EdgeConjugate(cc, 1, pc);
                this.twstc = pc.getTwstSym();
                this.flipc = pc.getFlipSym();
                this.prun = Math.max(this.prun,
                    getPruningMax(TwstFlipPrunMax, TwstFlipPrun,
                        (this.twstc >> 3) << 11 | FlipS2RF[this.flipc ^ (this.twstc & 7)]));
            }
            return this.prun <= depth;
        }
        CoordCube.prototype.doMovePrun = function(cc, m, isPhase1) {
            this.slice = SliceMove[cc.slice * N_MOVES + m];
            this.flip = FlipMove[(cc.flip >> 3) * N_MOVES + Sym8Move[m << 3 | cc.flip & 7]] ^ (cc.flip & 7);
            this.twst = TwstMove[(cc.twst >> 3) * N_MOVES + Sym8Move[m << 3 | cc.twst & 7]] ^ (cc.twst & 7);
            this.prun = Math.max(
                getPruningMax(SliceTwstPrunMax, SliceTwstPrun,
                    (this.twst >> 3) * N_SLICE + SliceConj[this.slice << 3 | this.twst & 7]),
                getPruningMax(SliceFlipPrunMax, SliceFlipPrun,
                    (this.flip >> 3) * N_SLICE + SliceConj[this.slice << 3 | this.flip & 7]),
                USE_TWST_FLIP_PRUN ? getPruningMax(TwstFlipPrunMax, TwstFlipPrun,
                    (this.twst >> 3) << 11 | FlipS2RF[this.flip ^ (this.twst & 7)]) : 0);
            return this.prun;
        }
        CoordCube.prototype.doMovePrunConj = function(cc, m) {
            m = SymMove[3][m];
            this.flipc = FlipMove[(cc.flipc >> 3) * N_MOVES + Sym8Move[m << 3 | cc.flipc & 7]] ^ (cc.flipc & 7);
            this.twstc = TwstMove[(cc.twstc >> 3) * N_MOVES + Sym8Move[m << 3 | cc.twstc & 7]] ^ (cc.twstc & 7);
            return getPruningMax(TwstFlipPrunMax, TwstFlipPrun,
                (this.twstc >> 3) << 11 | FlipS2RF[this.flipc ^ (this.twstc & 7)]);
        }
        Search.prototype.solution = function(facelets, maxDepth, probeMax, probeMin, verbose, firstAxisFilter, lastAxisFilter) {
            initPrunTables();
            var check = this.verify(facelets);
            if (check != 0) {
                return "Error " + Math.abs(check);
            }
            if (maxDepth === undefined) {
                maxDepth = 21;
            }
            if (probeMax === undefined) {
                probeMax = 1e9;
            }
            if (probeMin === undefined) {
                probeMin = 0;
            }
            if (verbose === undefined) {
                verbose = 0;
            }
            this.sol = maxDepth + 1;
            this.probe = 0;
            this.probeMax = probeMax;
            this.probeMin = Math.min(probeMin, probeMax);
            this.verbose = verbose;
            this.moveSol = null;
            this.isRec = false;
            this.firstFilters = [0, 0, 0, 0, 0, 0];
            this.lastFilters = [0, 0, 0, 0, 0, 0];
            for (var i = 0; i < 3; i++) {
                if (firstAxisFilter !== undefined) {
                    this.firstFilters[i] |= 0xe07 << (~~(urfMove[(3 - i) % 3][firstAxisFilter * 3] / 3)) * 3;
                    this.lastFilters[i + 3] |= 0xe07 << (~~(urfMove[(3 - i) % 3][firstAxisFilter * 3] / 3)) * 3;
                }
                if (lastAxisFilter !== undefined) {
                    this.lastFilters[i] |= 0xe07 << (~~(urfMove[(3 - i) % 3][lastAxisFilter * 3] / 3)) * 3;
                    this.firstFilters[i + 3] |= 0xe07 << (~~(urfMove[(3 - i) % 3][lastAxisFilter * 3] / 3)) * 3;
                }
            }
            this.initSearch();
            return this.search();
        }

        Search.prototype.initSearch = function() {
            this.conjMask = (TRY_INVERSE ? 0 : 0x38) | (TRY_THREE_AXES ? 0 : 0x36);
            this.maxPreMoves = this.conjMask > 7 ? 0 : MAX_PRE_MOVES;

            for (var i = 0; i < 6; i++) {
                this.urfCubieCube[i].init(this.cc.ca, this.cc.ea);
                this.urfCoordCube[i].setWithPrun(this.urfCubieCube[i], 20);
                this.cc.URFConjugate();
                if (i % 3 == 2) {
                    var tmp = new CubieCube().invFrom(this.cc);
                    this.cc.init(tmp.ca, tmp.ea);
                }
            }
        }

        Search.prototype.next = function(probeMax, probeMin, verbose) {
            this.probe = 0;
            this.probeMax = probeMax;
            this.probeMin = Math.min(probeMin, probeMax);
            this.moveSol = null;
            this.isRec = true;
            this.verbose = verbose;
            return this.search();
        }

        Search.prototype.verify = function(facelets) {
            if (this.cc.fromFacelet(facelets) == -1) {
                return -1;
            }
            var sum = 0;
            var edgeMask = 0;
            for (var e = 0; e < 12; e++) {
                edgeMask |= 1 << (this.cc.ea[e] & 0xf);
                sum ^= this.cc.ea[e] >> 4;
            }
            if (edgeMask != 0xfff) {
                return -2; // missing edges
            }
            if (sum != 0) {
                return -3;
            }
            var cornMask = 0;
            sum = 0;
            for (var c = 0; c < 8; c++) {
                cornMask |= 1 << (this.cc.ca[c] & 0xf);
                sum += this.cc.ca[c] >> 4;
            }
            if (cornMask != 0xff) {
                return -4; // missing corners
            }
            if (sum % 3 != 0) {
                return -5; // twisted corner
            }
            if ((getNParity(getNPermFull(this.cc.ea, 12), 12) ^ getNParity(this.cc.getCPerm(), 8)) != 0) {
                return -6; // parity error
            }
            return 0; // cube ok
        }

        Search.prototype.phase1PreMoves = function(maxl, lm, cc) {
            if (maxl == this.maxPreMoves - 1 && (this.lastFilter >> lm & 1) != 0) {
                return 1;
            }
            this.preMoveLen = this.maxPreMoves - maxl;
            if (this.isRec ? (this.depth1 == this.length1 - this.preMoveLen) :
                (this.preMoveLen == 0 || (0x36FB7 >> lm & 1) == 0)) {
                this.depth1 = this.length1 - this.preMoveLen;
                this.phase1Cubie[0].init(cc.ca, cc.ea) /* = cc*/ ;
                this.allowShorter = this.depth1 == MIN_P1LENGTH_PRE && this.preMoveLen != 0;

                if (this.nodeUD[this.depth1 + 1].setWithPrun(cc, this.depth1) &&
                    this.phase1(this.nodeUD[this.depth1 + 1], this.depth1, -1) == 0) {
                    return 0;
                }
            }

            if (maxl == 0 || this.preMoveLen + MIN_P1LENGTH_PRE >= this.length1) {
                return 1;
            }

            var skipMoves = 0;
            if (maxl == 1 || this.preMoveLen + 1 + MIN_P1LENGTH_PRE >= this.length1) { //last pre move
                skipMoves |= 0x36FB7; // 11 0110 1111 1011 0111
            }

            lm = ~~(lm / 3) * 3;
            for (var m = 0; m < 18; m++) {
                if (m == lm || m == lm - 9 || m == lm + 9) {
                    m += 2;
                    continue;
                }
                if (this.isRec && m != this.preMoves[this.maxPreMoves - maxl] || (skipMoves & 1 << m) != 0) {
                    continue;
                }
                CubieCube.CornMult(moveCube[m], cc, this.preMoveCubes[maxl]);
                CubieCube.EdgeMult(moveCube[m], cc, this.preMoveCubes[maxl]);
                this.preMoves[this.maxPreMoves - maxl] = m;
                var ret = this.phase1PreMoves(maxl - 1, m, this.preMoveCubes[maxl]);
                if (ret == 0) {
                    return 0;
                }
            }
            return 1;
        }

        Search.prototype.search = function() {
            for (this.length1 = this.isRec ? this.length1 : 0; this.length1 < this.sol; this.length1++) {
                for (this.urfIdx = this.isRec ? this.urfIdx : 0; this.urfIdx < 6; this.urfIdx++) {
                    if ((this.conjMask & 1 << this.urfIdx) != 0) {
                        continue;
                    }
                    this.firstFilter = this.firstFilters[this.urfIdx];
                    this.lastFilter = this.lastFilters[this.urfIdx];
                    if (this.phase1PreMoves(this.maxPreMoves, -30, this.urfCubieCube[this.urfIdx], 0) == 0) {
                        return this.moveSol == null ? "Error 8" : this.moveSol;
                    }
                }
            }
            return this.moveSol == null ? "Error 7" : this.moveSol;
        }

        Search.prototype.initPhase2Pre = function() {
            this.isRec = false;
            if (this.probe >= (this.moveSol == null ? this.probeMax : this.probeMin)) {
                return 0;
            }
            ++this.probe;

            for (var i = this.valid1; i < this.depth1; i++) {
                CubieCube.CornMult(this.phase1Cubie[i], moveCube[this.move[i]], this.phase1Cubie[i + 1]);
                CubieCube.EdgeMult(this.phase1Cubie[i], moveCube[this.move[i]], this.phase1Cubie[i + 1]);
            }
            this.valid1 = this.depth1;

            var ret = this.initPhase2(this.phase1Cubie[this.depth1]);
            if (ret == 0 || this.preMoveLen == 0 || ret == 2) {
                return ret;
            }

            var m = ~~(this.preMoves[this.preMoveLen - 1] / 3) * 3 + 1;
            CubieCube.CornMult(moveCube[m], this.phase1Cubie[this.depth1], this.phase1Cubie[this.depth1 + 1]);
            CubieCube.EdgeMult(moveCube[m], this.phase1Cubie[this.depth1], this.phase1Cubie[this.depth1 + 1]);

            this.preMoves[this.preMoveLen - 1] += 2 - this.preMoves[this.preMoveLen - 1] % 3 * 2;
            ret = this.initPhase2(this.phase1Cubie[this.depth1 + 1]);
            this.preMoves[this.preMoveLen - 1] += 2 - this.preMoves[this.preMoveLen - 1] % 3 * 2;
            return ret;
        }
        Search.prototype.initPhase2 = function(phase2Cubie) {
            var p2corn = phase2Cubie.getCPermSym();
            var p2csym = p2corn & 0xf;
            p2corn >>= 4;
            var p2edge = phase2Cubie.getEPermSym();
            var p2esym = p2edge & 0xf;
            p2edge >>= 4;
            var p2mid = phase2Cubie.getMPerm();
            var prun = Math.max(
                getPruningMax(EPermCCombPPrunMax, EPermCCombPPrun,
                    p2edge * N_COMB + CCombPConj[(Perm2CombP[p2corn] & 0xff) << 4 | SymMultInv[p2esym][p2csym]]),
                getPruningMax(MCPermPrunMax, MCPermPrun,
                    p2corn * N_MPERM + MPermConj[p2mid << 4 | p2csym]));
            var maxDep2 = Math.min(MAX_DEPTH2, this.sol - this.length1);
            if (prun >= maxDep2) {
                return prun > maxDep2 ? 2 : 1;
            }
            var depth2;
            for (depth2 = maxDep2 - 1; depth2 >= prun; depth2--) {
                var ret = this.phase2(p2edge, p2esym, p2corn, p2csym, p2mid, depth2, this.depth1, 10);
                if (ret < 0) {
                    break;
                }
                depth2 -= ret;
                this.moveSol = [];
                for (var i = 0; i < this.depth1 + depth2; i++) {
                    this.appendSolMove(this.move[i]);
                }
                for (var i = this.preMoveLen - 1; i >= 0; i--) {
                    this.appendSolMove(this.preMoves[i]);
                }
                this.sol = this.moveSol.length;
                this.moveSol = this.solutionToString();
            }
            if (depth2 != maxDep2 - 1) { //At least one solution has been found.
                return this.probe >= this.probeMin ? 0 : 1;
            } else {
                return 1;
            }
        }
        Search.prototype.phase1 = function(node, maxl, lm) {
            if (maxl == this.depth1 - 1 && (this.firstFilter >> lm & 1) != 0) {
                return 1;
            }
            if (node.prun == 0 && maxl < 5) {
                if (this.allowShorter || maxl == 0) {
                    this.depth1 -= maxl;
                    var ret = this.initPhase2Pre();
                    this.depth1 += maxl;
                    return ret;
                } else {
                    return 1;
                }
            }
            for (var axis = 0; axis < 18; axis += 3) {
                if (axis == lm || axis == lm - 9) {
                    continue;
                }
                for (var power = 0; power < 3; power++) {
                    var m = axis + power;

                    if (this.isRec && m != this.move[this.depth1 - maxl]) {
                        continue;
                    }

                    var prun = this.nodeUD[maxl].doMovePrun(node, m, true);
                    if (prun > maxl) {
                        break;
                    } else if (prun == maxl) {
                        continue;
                    }

                    if (USE_CONJ_PRUN) {
                        prun = this.nodeUD[maxl].doMovePrunConj(node, m);
                        if (prun > maxl) {
                            break;
                        } else if (prun == maxl) {
                            continue;
                        }
                    }
                    this.move[this.depth1 - maxl] = m;
                    this.valid1 = Math.min(this.valid1, this.depth1 - maxl);
                    var ret = this.phase1(this.nodeUD[maxl], maxl - 1, axis);
                    if (ret == 0) {
                        return 0;
                    } else if (ret == 2) {
                        break;
                    }
                }
            }
            return 1;
        }
        Search.prototype.appendSolMove = function(curMove) {
            if (this.moveSol.length == 0) {
                this.moveSol.push(curMove);
                return;
            }
            var axisCur = ~~(curMove / 3);
            var axisLast = ~~(this.moveSol[this.moveSol.length - 1] / 3);
            if (axisCur == axisLast) {
                var pow = (curMove % 3 + this.moveSol[this.moveSol.length - 1] % 3 + 1) % 4;
                if (pow == 3) {
                    this.moveSol.pop();
                } else {
                    this.moveSol[this.moveSol.length - 1] = axisCur * 3 + pow;
                }
                return;
            }
            if (this.moveSol.length > 1 &&
                axisCur % 3 == axisLast % 3 &&
                axisCur == ~~(this.moveSol[this.moveSol.length - 2] / 3)) {
                var pow = (curMove % 3 + this.moveSol[this.moveSol.length - 2] % 3 + 1) % 4;
                if (pow == 3) {
                    this.moveSol[this.moveSol.length - 2] = this.moveSol[this.moveSol.length - 1];
                    this.moveSol.pop();
                } else {
                    this.moveSol[this.moveSol.length - 2] = axisCur * 3 + pow;
                }
                return;
            }
            this.moveSol.push(curMove);
        }
        Search.prototype.phase2 = function(edge, esym, corn, csym, mid, maxl, depth, lm) {
            if (this.depth1 == 0 && depth == 1 && (this.firstFilter >> ud2std[lm] & 1) != 0) {
                return -1;
            }
            if (edge == 0 && corn == 0 && mid == 0 && (this.preMoveLen > 0 || (this.lastFilter >> ud2std[lm] & 1) == 0)) {
                return maxl;
            }
            var moveMask = ckmv2bit[lm];
            for (var m = 0; m < 10; m++) {
                if ((moveMask >> m & 1) != 0) {
                    m += 0x42 >> m & 3;
                    continue;
                }
                var midx = MPermMove[mid * N_MOVES2 + m];
                var cornx = CPermMove[corn * N_MOVES2 + SymMoveUD[csym][m]];
                var csymx = SymMult[cornx & 0xf][csym];
                cornx >>= 4;
                if (getPruningMax(MCPermPrunMax, MCPermPrun,
                        cornx * N_MPERM + MPermConj[midx << 4 | csymx]) >= maxl) {
                    continue;
                }
                var edgex = EPermMove[edge * N_MOVES2 + SymMoveUD[esym][m]];
                var esymx = SymMult[edgex & 0xf][esym];
                edgex >>= 4;
                if (getPruningMax(EPermCCombPPrunMax, EPermCCombPPrun,
                        edgex * N_COMB + CCombPConj[(Perm2CombP[cornx] & 0xff) << 4 | SymMultInv[esymx][csymx]]) >= maxl) {
                    continue;
                }
                var edgei = getPermSymInv(edgex, esymx, false);
                var corni = getPermSymInv(cornx, csymx, true);
                if (getPruningMax(EPermCCombPPrunMax, EPermCCombPPrun,
                        (edgei >> 4) * N_COMB + CCombPConj[(Perm2CombP[corni >> 4] & 0xff) << 4 | SymMultInv[edgei & 0xf][corni & 0xf]]) >= maxl) {
                    continue;
                }

                var ret = this.phase2(edgex, esymx, cornx, csymx, midx, maxl - 1, depth + 1, m);
                if (ret >= 0) {
                    this.move[depth] = ud2std[m];
                    return ret;
                }
            }
            return -1;
        }
        Search.prototype.solutionToString = function() {
            var sb = '';
            var urf = (this.verbose & INVERSE_SOLUTION) != 0 ? (this.urfIdx + 3) % 6 : this.urfIdx;
            if (urf < 3) {
                for (var s = 0; s < this.moveSol.length; ++s) {
                    sb += move2str[urfMove[urf][this.moveSol[s]]] + ' ';
                }
            } else {
                for (var s = this.moveSol.length - 1; s >= 0; --s) {
                    sb += move2str[urfMove[urf][this.moveSol[s]]] + ' ';
                }
            }
            return sb;
        }

        var moveCube = [];
        var SymCube = [];
        var SymMult = [];
        var SymMultInv = [];
        var SymMove = [];
        var SymMoveUD = [];
        var Sym8Move = [];
        var FlipS2R = [];
        var FlipR2S = [];
        var FlipSelfSym = [];
        var FlipS2RF = [];
        var TwstS2R = [];
        var TwstR2S = [];
        var TwstSelfSym = [];
        var EPermS2R = [];
        var EPermR2S = [];
        var PermSelfSym = [];
        var Perm2CombP = [];
        var PermInvEdgeSym = [];
        var TwstMove = [];
        var FlipMove = [];
        var SliceMove = [];
        var SliceConj = [];
        var SliceTwstPrun = [];
        var SliceFlipPrun = [];
        var TwstFlipPrun = [];

        //phase2
        var CPermMove = [];
        var EPermMove = [];
        var MPermMove = [];
        var MPermConj = [];
        var CCombPMove = [];
        var CCombPConj = [];
        var MCPermPrun = [];
        var EPermCCombPPrun = [];

        var TwstFlipPrunMax = 15;
        var SliceTwstPrunMax = 15;
        var SliceFlipPrunMax = 15;
        var MCPermPrunMax = 15;
        var EPermCCombPPrunMax = 15;

        { //init move cubes
            for (var i = 0; i < 18; i++) {
                moveCube[i] = new CubieCube()
            }
            moveCube[0].initCoord(15120, 0, 119750400, 0);
            moveCube[3].initCoord(21021, 1494, 323403417, 0);
            moveCube[6].initCoord(8064, 1236, 29441808, 550);
            moveCube[9].initCoord(9, 0, 5880, 0);
            moveCube[12].initCoord(1230, 412, 2949660, 0);
            moveCube[15].initCoord(224, 137, 328552, 137);
            for (var a = 0; a < 18; a += 3) {
                for (var p = 0; p < 2; p++) {
                    CubieCube.EdgeMult(moveCube[a + p], moveCube[a], moveCube[a + p + 1]);
                    CubieCube.CornMult(moveCube[a + p], moveCube[a], moveCube[a + p + 1]);
                }
            }
            CubieCube.urf1 = new CubieCube().initCoord(2531, 1373, 67026819, 1367);
            CubieCube.urf2 = new CubieCube().initCoord(2089, 1906, 322752913, 2040);
        }

        function initBasic() {
            //init sym cubes
            var c = new CubieCube();
            var d = new CubieCube();
            var t;

            var f2 = new CubieCube().initCoord(28783, 0, 259268407, 0);
            var u4 = new CubieCube().initCoord(15138, 0, 119765538, 7);
            var lr2 = new CubieCube().initCoord(5167, 0, 83473207, 0);
            for (var i = 0; i < 8; i++) {
                lr2.ca[i] |= 3 << 4;
            }
            for (var i = 0; i < 16; i++) {
                SymCube[i] = new CubieCube().init(c.ca, c.ea);
                CubieCube.CornMultFull(c, u4, d);
                CubieCube.EdgeMult(c, u4, d);
                c.init(d.ca, d.ea);
                if (i % 4 == 3) {
                    CubieCube.CornMultFull(c, lr2, d);
                    CubieCube.EdgeMult(c, lr2, d);
                    c.init(d.ca, d.ea);
                }
                if (i % 8 == 7) {
                    CubieCube.CornMultFull(c, f2, d);
                    CubieCube.EdgeMult(c, f2, d);
                    c.init(d.ca, d.ea);
                }
            }

            // gen sym tables
            for (var i = 0; i < 16; i++) {
                SymMult[i] = [];
                SymMultInv[i] = [];
                SymMove[i] = [];
                Sym8Move[i] = [];
                SymMoveUD[i] = [];
            }
            for (var i = 0; i < 16; i++) {
                for (var j = 0; j < 16; j++) {
                    SymMult[i][j] = i ^ j ^ (0x14ab4 >> j & i << 1 & 2); // SymMult[i][j] = (i ^ j ^ (0x14ab4 >> j & i << 1 & 2)));
                    SymMultInv[SymMult[i][j]][j] = i;
                }
            }

            c = new CubieCube();
            for (var s = 0; s < 16; s++) {
                for (var j = 0; j < 18; j++) {
                    CubieCube.CornConjugate(moveCube[j], SymMultInv[0][s], c);
                    outloop: for (var m = 0; m < 18; m++) {
                        for (var k = 0; k < 8; k++) {
                            if (moveCube[m].ca[k] != c.ca[k]) {
                                continue outloop;
                            }
                        }
                        SymMove[s][j] = m;
                        SymMoveUD[s][std2ud[j]] = std2ud[m];
                        break;
                    }
                    if (s % 2 == 0) {
                        Sym8Move[j << 3 | s >> 1] = SymMove[s][j];
                    }
                }
            }

            // init sym 2 raw tables
            function initSym2Raw(N_RAW, Sym2Raw, Raw2Sym, SelfSym, coord, setFunc, getFunc) {
                var N_RAW_HALF = (N_RAW + 1) >> 1;
                var c = new CubieCube();
                var d = new CubieCube();
                var count = 0;
                var sym_inc = coord >= 2 ? 1 : 2;
                var conjFunc = coord != 1 ? CubieCube.EdgeConjugate : CubieCube.CornConjugate;

                for (var i = 0; i < N_RAW; i++) {
                    if (Raw2Sym[i] !== undefined) {
                        continue;
                    }
                    setFunc.call(c, i);
                    for (var s = 0; s < 16; s += sym_inc) {
                        conjFunc(c, s, d);
                        var idx = getFunc.call(d);
                        if (USE_TWST_FLIP_PRUN && coord == 0) {
                            FlipS2RF[count << 3 | s >> 1] = idx;
                        }
                        if (idx == i) {
                            SelfSym[count] |= 1 << (s / sym_inc);
                        }
                        Raw2Sym[idx] = (count << 4 | s) / sym_inc;
                    }
                    Sym2Raw[count++] = i;
                }
                return count;
            }

            initSym2Raw(N_FLIP, FlipS2R, FlipR2S, FlipSelfSym, 0, CubieCube.prototype.setFlip, CubieCube.prototype.getFlip);
            initSym2Raw(N_TWST, TwstS2R, TwstR2S, TwstSelfSym, 1, CubieCube.prototype.setTwst, CubieCube.prototype.getTwst);
            initSym2Raw(N_PERM, EPermS2R, EPermR2S, PermSelfSym, 2, CubieCube.prototype.setEPerm, CubieCube.prototype.getEPerm);

            var cc = new CubieCube();
            for (var i = 0; i < N_PERM_SYM; i++) {
                setNPerm(cc.ea, EPermS2R[i], 8);
                Perm2CombP[i] = getComb(cc.ea, 0) + getNParity(EPermS2R[i], 8) * 70;
                c.invFrom(cc);
                PermInvEdgeSym[i] = EPermR2S[c.getEPerm()];
            }

            // init coord tables
            c = new CubieCube();
            d = new CubieCube();
            function initSymMoveTable(moveTable, SymS2R, N_SIZE, N_MOVES, setFunc, getFunc, multFunc, ud2std) {
                for (var i = 0; i < N_SIZE; i++) {
                    setFunc.call(c, SymS2R[i]);
                    for (var j = 0; j < N_MOVES; j++) {
                        multFunc(c, moveCube[ud2std ? ud2std[j] : j], d);
                        moveTable[i * N_MOVES + j] = getFunc.call(d);
                    }
                }
            }

            initSymMoveTable(FlipMove, FlipS2R, N_FLIP_SYM, N_MOVES,
                CubieCube.prototype.setFlip, CubieCube.prototype.getFlipSym, CubieCube.EdgeMult);
            initSymMoveTable(TwstMove, TwstS2R, N_TWST_SYM, N_MOVES,
                CubieCube.prototype.setTwst, CubieCube.prototype.getTwstSym, CubieCube.CornMult);
            initSymMoveTable(EPermMove, EPermS2R, N_PERM_SYM, N_MOVES2,
                CubieCube.prototype.setEPerm, CubieCube.prototype.getEPermSym, CubieCube.EdgeMult, ud2std);
            initSymMoveTable(CPermMove, EPermS2R, N_PERM_SYM, N_MOVES2,
                CubieCube.prototype.setCPerm, CubieCube.prototype.getCPermSym, CubieCube.CornMult, ud2std);

            for (var i = 0; i < N_SLICE; i++) {
                c.setSlice(i);
                for (var j = 0; j < N_MOVES; j++) {
                    CubieCube.EdgeMult(c, moveCube[j], d);
                    SliceMove[i * N_MOVES + j] = d.getSlice();
                }
                for (var j = 0; j < 16; j += 2) {
                    CubieCube.EdgeConjugate(c, SymMultInv[0][j], d);
                    SliceConj[i << 3 | j >> 1] = d.getSlice();
                }
            }

            for (var i = 0; i < N_MPERM; i++) {
                c.setMPerm(i);
                for (var j = 0; j < N_MOVES2; j++) {
                    CubieCube.EdgeMult(c, moveCube[ud2std[j]], d);
                    MPermMove[i * N_MOVES2 + j] = d.getMPerm();
                }
                for (var j = 0; j < 16; j++) {
                    CubieCube.EdgeConjugate(c, SymMultInv[0][j], d);
                    MPermConj[i << 4 | j] = d.getMPerm();
                }
            }

            for (var i = 0; i < N_COMB; i++) {
                c.setCComb(i % 70);
                for (var j = 0; j < N_MOVES2; j++) {
                    CubieCube.CornMult(c, moveCube[ud2std[j]], d);
                    CCombPMove[i * N_MOVES2 + j] = d.getCComb() + 70 * ((0xA5 >> j & 1) ^ ~~(i / 70));
                }
                for (var j = 0; j < 16; j++) {
                    CubieCube.CornConjugate(c, SymMultInv[0][j], d);
                    CCombPConj[i << 4 | j] = d.getCComb() + 70 * ~~(i / 70);
                }
            }
        }

        //init pruning tables
        var InitPrunProgress = -1;

        function initRawSymPrun(PrunTable, N_RAW, N_SYM, RawMove, RawConj, SymMove, SelfSym, PrunFlag) {
            var SYM_SHIFT = PrunFlag & 0xf;
            var SYM_E2C_MAGIC = ((PrunFlag >> 4) & 1) == 1 ? 0x00DDDD00 : 0x00000000;
            var IS_PHASE2 = ((PrunFlag >> 5) & 1) == 1;
            var INV_DEPTH = PrunFlag >> 8 & 0xf;
            var MAX_DEPTH = PrunFlag >> 12 & 0xf;
            var MIN_DEPTH = PrunFlag >> 16 & 0xf;

            var SYM_MASK = (1 << SYM_SHIFT) - 1;
            var ISTFP = RawMove == null;
            var N_SIZE = N_RAW * N_SYM;
            var N_MOVES = IS_PHASE2 ? 10 : 18;
            var NEXT_AXIS_MAGIC = N_MOVES == 10 ? 0x42 : 0x92492;

            var depth = getPruning(PrunTable, N_SIZE) - 1;

            if (depth == -1) {
                for (var i = 0; i < (N_SIZE >> 3) + 1; i++) {
                    PrunTable[i] = -1;
                }
                setPruning(PrunTable, 0, 0 ^ 0xf);
                depth = 0;
            } else {
                setPruning(PrunTable, N_SIZE, 0xf ^ (depth + 1));
            }

            var SEARCH_DEPTH = PARTIAL_INIT_LEVEL > 0 ?
                Math.min(Math.max(depth + 1, MIN_DEPTH), MAX_DEPTH) : MAX_DEPTH;

            while (depth < SEARCH_DEPTH) {
                var inv = depth > INV_DEPTH;
                var select = inv ? 0xf : depth;
                var selArrMask = select * 0x11111111;
                var check = inv ? depth : 0xf;
                depth++;
                InitPrunProgress++;
                var xorVal = depth ^ 0xf;
                var done = 0;
                var val = 0;
                for (var i = 0; i < N_SIZE; i++, val >>= 4) {
                    if ((i & 7) == 0) {
                        val = PrunTable[i >> 3];
                        if (!hasZero(val ^ selArrMask)) {
                            i += 7;
                            continue;
                        }
                    }
                    if ((val & 0xf) != select) {
                        continue;
                    }
                    var raw = i % N_RAW;
                    var sym = ~~(i / N_RAW);
                    var flip = 0,
                        fsym = 0;
                    if (ISTFP) {
                        flip = FlipR2S[raw];
                        fsym = flip & 7;
                        flip >>= 3;
                    }

                    for (var m = 0; m < N_MOVES; m++) {
                        var symx = SymMove[sym * N_MOVES + m];
                        var rawx;
                        if (ISTFP) {
                            rawx = FlipS2RF[
                                FlipMove[flip * N_MOVES + Sym8Move[m << 3 | fsym]] ^
                                fsym ^ (symx & SYM_MASK)];
                        } else {
                            rawx = RawConj[RawMove[raw * N_MOVES + m] << SYM_SHIFT | symx & SYM_MASK];
                        }
                        symx >>= SYM_SHIFT;
                        var idx = symx * N_RAW + rawx;
                        var prun = getPruning(PrunTable, idx);
                        if (prun != check) {
                            if (prun < depth - 1) {
                                m += NEXT_AXIS_MAGIC >> m & 3;
                            }
                            continue;
                        }
                        done++;
                        if (inv) {
                            setPruning(PrunTable, i, xorVal);
                            break;
                        }
                        setPruning(PrunTable, idx, xorVal);
                        for (var j = 1, selfSym = SelfSym[symx];
                                (selfSym >>= 1) != 0; j++) {
                            if ((selfSym & 1) != 1) {
                                continue;
                            }
                            var idxx = symx * N_RAW;
                            if (ISTFP) {
                                idxx += FlipS2RF[FlipR2S[rawx] ^ j];
                            } else {
                                idxx += RawConj[rawx << SYM_SHIFT | (j ^ (SYM_E2C_MAGIC >> (j << 1) & 3))];
                            }
                            if (getPruning(PrunTable, idxx) == check) {
                                setPruning(PrunTable, idxx, xorVal);
                                done++;
                            }
                        }
                    }
                }
                // console.log(depth, done, InitPrunProgress);
            }
            setPruning(PrunTable, N_SIZE, (depth + 1) ^ 0xf);
            return depth + 1;
        }

        function doInitPrunTables(targetProgress) {
            if (USE_TWST_FLIP_PRUN) {
                TwstFlipPrunMax = initRawSymPrun(
                    TwstFlipPrun, N_FLIP, N_TWST_SYM,
                    null, null,
                    TwstMove, TwstSelfSym, 0x19603
                );
            }
            if (InitPrunProgress > targetProgress) {
                return;
            }
            SliceTwstPrunMax = initRawSymPrun(
                SliceTwstPrun, N_SLICE, N_TWST_SYM,
                SliceMove, SliceConj,
                TwstMove, TwstSelfSym, 0x69603
            );
            if (InitPrunProgress > targetProgress) {
                return;
            }
            SliceFlipPrunMax = initRawSymPrun(
                SliceFlipPrun, N_SLICE, N_FLIP_SYM,
                SliceMove, SliceConj,
                FlipMove, FlipSelfSym, 0x69603
            );
            if (InitPrunProgress > targetProgress) {
                return;
            }
            MCPermPrunMax = initRawSymPrun(
                MCPermPrun, 24, N_PERM_SYM,
                MPermMove, MPermConj,
                CPermMove, PermSelfSym, 0x8ea34
            );
            if (InitPrunProgress > targetProgress) {
                return;
            }
            EPermCCombPPrunMax = initRawSymPrun(
                EPermCCombPPrun, N_COMB, N_PERM_SYM,
                CCombPMove, CCombPConj,
                EPermMove, PermSelfSym, 0x7d824
            );
        }

        function initPrunTables() {
            if (InitPrunProgress < 0) {
                initBasic();
                InitPrunProgress = 0;
            }
            if (InitPrunProgress == 0) {
                doInitPrunTables(99);
            } else if (InitPrunProgress < 54) {
                doInitPrunTables(InitPrunProgress);
            } else {
                return true;
            }
            return false;
        }

        function randomCube() {
            var ep, cp;
            var eo = ~~(Math.random() * 2048);
            var co = ~~(Math.random() * 2187);
            do {
                ep = ~~(Math.random() * fact[12]);
                cp = ~~(Math.random() * fact[8]);
            } while (getNParity(cp, 8) != getNParity(ep, 12));
            var cc = new CubieCube().initCoord(cp, co, ep, eo);
            return cc.toFaceCube();
        }
        function fromScramble(s) {
            var j = 0;
            var axis = -1;
            var c1 = new CubieCube();
            var c2 = new CubieCube();
            for (var i = 0; i < s.length; i++) {
                switch (s[i]) {
                    case 'U':
                    case 'R':
                    case 'F':
                    case 'D':
                    case 'L':
                    case 'B':
                        axis = "URFDLB".indexOf(s[i]) * 3;
                        break;
                    case ' ':
                        if (axis != -1) {
                            CubieCube.CornMult(c1, moveCube[axis], c2);
                            CubieCube.EdgeMult(c1, moveCube[axis], c2);
                            c1.init(c2.ca, c2.ea);
                        }
                        axis = -1;
                        break;
                    case '2':
                        axis++;
                        break;
                    case '\'':
                        axis += 2;
                        break;
                    default:
                        continue;
                }
            }
            if (axis != -1) {
                CubieCube.CornMult(c1, moveCube[axis], c2);
                CubieCube.EdgeMult(c1, moveCube[axis], c2);
                c1.init(c2.ca, c2.ea);
            }
            return c2.toFaceCube();
        }

        return {
            Search: Search,
            solve: function(facelet) {
                return new Search().solution(facelet);
            },
            randomCube: randomCube,
            fromScramble: fromScramble,
            initFull: function() {
                PARTIAL_INIT_LEVEL = 0;
                initPrunTables();
            },
            INVERSE_SOLUTION: INVERSE_SOLUTION
        }
    })();

    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = min2phase;
    }
    </script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .pointer-events-auto { pointer-events: auto; }

        .glass-panel {
            background: rgba(30, 30, 35, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
        }

        .color-btn {
            width: 40px; height: 40px; border-radius: 50%;
            border: 3px solid transparent; transition: transform 0.2s, border-color 0.2s; cursor: pointer;
        }
        .color-btn.active { transform: scale(1.2); border-color: white; box-shadow: 0 0 12px rgba(255,255,255,0.6); }

        .control-btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: white; transition: all 0.2s;
        }
        .control-btn:hover:not(:disabled) { background: rgba(255, 255, 255, 0.2); transform: translateY(-2px); }
        .control-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        #msg-box { opacity: 0; transition: opacity 0.3s, transform 0.3s; transform: translateY(-20px); }
        #msg-box.show { opacity: 1; transform: translateY(20px); }
        
        /* Modal */
        #error-modal {
            display: none;
            position: fixed; z-index: 100; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
            justify-content: center; align-items: center;
        }
        #error-modal.active { display: flex; }

        /* Debug String Output */
        #debug-string {
            font-family: monospace; font-size: 10px; color: #666; 
            word-break: break-all; margin-top: 5px;
        }
    </style>
</head>
<body>

    <!-- Error Modal -->
    <div id="error-modal" class="pointer-events-auto" onclick="if(event.target.id==='error-modal') app.closeModal()">
        <div class="glass-panel p-8 rounded-2xl max-w-md mx-4 text-center">
            <div class="text-red-400 mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                </svg>
            </div>
            <h3 class="text-xl font-bold text-white mb-2">无法求解</h3>
            <div id="error-msg" class="text-gray-300 text-sm mb-6 whitespace-pre-wrap"></div>
            <button onclick="app.closeModal()" class="bg-red-600 hover:bg-red-500 text-white px-6 py-2 rounded-xl font-bold transition w-full">
                我知道了
            </button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="p-4 flex justify-between items-start pointer-events-auto">
            <div class="glass-panel p-5 rounded-xl text-white max-w-md w-full sm:w-auto">
                <h1 class="text-xl font-bold mb-2 flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-indigo-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                    </svg>
                    魔方还原助手
                </h1>
                <div class="text-sm text-gray-300 space-y-1">
                    <p>1. <span class="text-indigo-300">填色</span>：点击颜色，再点击方块。<span class="text-red-400">需填满6个面！</span></p>
                    <p>2. <span class="text-indigo-300">旋转</span>：拖动背景旋转魔方视角。</p>
                </div>
                <div id="debug-string" class="hidden sm:block">初始化中...</div>
                <div class="mt-3 flex gap-2">
                    <button onclick="app.resetCamera()" class="text-xs bg-gray-700 hover:bg-gray-600 px-3 py-1.5 rounded text-white transition">重置视角</button>
                    <button onclick="app.resetCube()" class="text-xs bg-red-900/50 hover:bg-red-800 px-3 py-1.5 rounded text-white transition border border-red-800">重置魔方</button>
                </div>
            </div>
        </div>

        <div class="flex flex-col items-center justify-start mt-20 pointer-events-none h-full absolute w-full top-0 left-0">
            <div id="msg-box" class="glass-panel px-6 py-3 rounded-full text-white font-bold text-lg shadow-xl mb-4">就绪</div>

            <div id="step-display" class="hidden glass-panel px-8 py-4 rounded-2xl flex-col items-center animate-fade-in">
                <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">当前步骤</div>
                <div class="text-4xl font-black text-white mb-2" id="current-move-text">R</div>
                <div class="w-full bg-gray-700 rounded-full h-1.5 mb-2">
                    <div id="progress-bar" class="bg-indigo-500 h-1.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div class="text-xs text-gray-400">步骤 <span id="step-counter">0/0</span></div>
            </div>
        </div>

        <div class="p-6 w-full flex flex-col items-center gap-4 pointer-events-auto bg-gradient-to-t from-black/90 via-black/50 to-transparent pt-12">
            
            <div id="edit-controls" class="flex flex-col items-center w-full max-w-lg gap-4 transition-all duration-300">
                <div class="flex gap-3 sm:gap-4 bg-black/40 p-3 rounded-2xl backdrop-blur-md border border-white/10">
                    <div class="color-btn bg-white active" onclick="app.selectColor('U')" title="顶 (U) - 白色"></div>
                    <div class="color-btn bg-yellow-400" onclick="app.selectColor('D')" title="底 (D) - 黄色"></div>
                    <div class="color-btn bg-green-600" onclick="app.selectColor('F')" title="前 (F) - 绿色"></div>
                    <div class="color-btn bg-blue-600" onclick="app.selectColor('B')" title="后 (B) - 蓝色"></div>
                    <div class="color-btn bg-red-600" onclick="app.selectColor('R')" title="右 (R) - 红色"></div>
                    <div class="color-btn bg-orange-500" onclick="app.selectColor('L')" title="左 (L) - 橙色"></div>
                </div>

                <div class="flex gap-3 w-full">
                    <button onclick="app.scramble()" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white py-3 rounded-xl font-bold transition shadow-lg border border-gray-600 flex justify-center items-center gap-2">
                        随机打乱
                    </button>
                    <button onclick="app.startSolveMode()" id="btn-solve-action" class="flex-1 bg-indigo-600 hover:bg-indigo-500 text-white py-3 rounded-xl font-bold transition shadow-lg shadow-indigo-900/50 border border-indigo-400 flex justify-center items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" /></svg>
                        计算求解
                    </button>
                </div>
            </div>

            <div id="solve-controls" class="hidden w-full max-w-lg transition-all duration-300">
                <div class="glass-panel p-2 rounded-2xl flex justify-between items-center gap-2">
                    <button onclick="app.prevStep()" id="btn-prev" class="control-btn p-4 rounded-xl flex-1 flex justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7" /></svg>
                    </button>
                    <button onclick="app.toggleAutoPlay()" id="btn-play" class="control-btn p-4 rounded-xl flex-[2] bg-indigo-600 hover:bg-indigo-500 border-indigo-400 flex justify-center gap-2 items-center font-bold">
                        <span id="play-text">播放</span>
                        <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    </button>
                    <button onclick="app.nextStep()" id="btn-next" class="control-btn p-4 rounded-xl flex-1 flex justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7" /></svg>
                    </button>
                </div>
                <button onclick="app.exitSolveMode()" class="w-full mt-3 text-gray-400 text-sm hover:text-white py-2">
                    退出还原模式
                </button>
            </div>
        </div>
    </div>

<script>
/**
 * 3D Rubik's Cube with Algorithm Interface
 */

class RubiksApp {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.cubies = []; 
        this.isAnimating = false;
        
        // State
        this.solutionQueue = []; 
        this.currentStepIndex = -1; 
        this.isPlaying = false;
        this.playInterval = null;
        this.isSolverReady = false;

        // Color Definitions (Standard Scheme)
        this.colors = {
            'U': 0xffffff, // White
            'D': 0xffd500, // Yellow
            'F': 0x009e60, // Green
            'B': 0x0051ba, // Blue
            'R': 0xc41e3a, // Red
            'L': 0xff5800, // Orange
            'Core': 0x111111 // Black
        };

        // Reverse lookup for reading state
        this.hexToChar = {
            0xffffff: 'U', 0xffd500: 'D', 0x009e60: 'F',
            0x0051ba: 'B', 0xc41e3a: 'R', 0xff5800: 'L'
        };
        
        this.selectedColor = 'U';
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();

        this.axes = {
            'x': new THREE.Vector3(1, 0, 0),
            'y': new THREE.Vector3(0, 1, 0),
            'z': new THREE.Vector3(0, 0, 1)
        };

        this.init();
        this.initSolverLib();
    }

    init() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a1a1a);
        
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        this.camera.position.set(6, 5, 8);
        this.camera.lookAt(0, 0, 0);

        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        this.scene.add(dirLight);
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
        backLight.position.set(-10, -10, -10);
        this.scene.add(backLight);

        this.createCube();

        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enablePan = false;

        window.addEventListener('resize', () => this.onWindowResize());
        this.renderer.domElement.addEventListener('pointerdown', (e) => this.onCanvasClick(e));

        this.animate();
    }

    initSolverLib() {
        // Initialize min2phase.js solver (Now embedded locally!)
        setTimeout(() => {
            if (typeof min2phase !== 'undefined') {
                document.getElementById('debug-string').innerText = "算法库初始化中...";
                document.getElementById('btn-solve-action').disabled = true;
                
                try {
                    // min2phase initialization usually happens automatically or via init()
                    min2phase.initFull(); // Use initFull from the provided code snippet if available, else fallback to implicit
                    this.isSolverReady = true;
                    document.getElementById('debug-string').innerText = "算法库就绪 (离线)";
                    document.getElementById('btn-solve-action').disabled = false;
                } catch(e) {
                    console.error("Solver Init Error:", e);
                    document.getElementById('debug-string').innerText = "算法库初始化失败";
                    document.getElementById('btn-solve-action').disabled = false;
                }
            } else {
                document.getElementById('debug-string').innerText = "提示: 算法库未加载 (使用简易模式)";
                console.warn("min2phase library missing. Fallback mode enabled.");
                document.getElementById('btn-solve-action').disabled = false;
            }
        }, 500);
    }

    createCube() {
        this.cubies.forEach(c => this.scene.remove(c));
        this.cubies = [];
        const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
        
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    // Materials Order: R, L, U, D, F, B
                    const materials = [
                        new THREE.MeshStandardMaterial({ color: x === 1 ? this.colors['R'] : this.colors['Core'] }), // 0: Right
                        new THREE.MeshStandardMaterial({ color: x === -1 ? this.colors['L'] : this.colors['Core'] }), // 1: Left
                        new THREE.MeshStandardMaterial({ color: y === 1 ? this.colors['U'] : this.colors['Core'] }), // 2: Top
                        new THREE.MeshStandardMaterial({ color: y === -1 ? this.colors['D'] : this.colors['Core'] }), // 3: Bottom
                        new THREE.MeshStandardMaterial({ color: z === 1 ? this.colors['F'] : this.colors['Core'] }), // 4: Front
                        new THREE.MeshStandardMaterial({ color: z === -1 ? this.colors['B'] : this.colors['Core'] }), // 5: Back
                    ];
                    const mesh = new THREE.Mesh(geometry, materials);
                    mesh.position.set(x, y, z);
                    this.cubies.push(mesh);
                    this.scene.add(mesh);
                }
            }
        }
    }

    resetCube() {
        this.solutionQueue = [];
        this.currentStepIndex = -1;
        this.createCube();
        this.showMessage("魔方已重置");
        this.exitSolveMode();
        document.getElementById('debug-string').innerText = this.isSolverReady ? "算法库就绪 (离线)" : "等待...";
    }
    
    exitSolveMode() {
        this.stopAutoPlay();
        document.getElementById('edit-controls').classList.remove('hidden');
        document.getElementById('edit-controls').classList.add('flex');
        document.getElementById('solve-controls').classList.add('hidden');
        document.getElementById('step-display').classList.add('hidden');
        document.getElementById('step-display').classList.remove('flex');
        this.currentStepIndex = -1;
        this.solutionQueue = [];
        this.showMessage("退出还原模式");
    }

    // --- Interaction ---

    onCanvasClick(event) {
        if (this.isAnimating || this.isPlaying) return;
        const solveControls = document.getElementById('solve-controls');
        if (!solveControls.classList.contains('hidden')) {
            this.showMessage("还原模式下不可修改颜色", 1000);
            return;
        }

        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.cubies);

        if (intersects.length > 0) {
            const intersect = intersects[0];
            const object = intersect.object;
            const materialIndex = intersect.face.materialIndex;
            
            // Center piece check
            const x = Math.round(object.position.x);
            const y = Math.round(object.position.y);
            const z = Math.round(object.position.z);
            
            if (Math.abs(x) + Math.abs(y) + Math.abs(z) === 1) {
                 this.showMessage("中心块颜色不可修改", 2000);
                 return;
            }

            this.highlightFace(object);
            object.material[materialIndex].color.setHex(this.colors[this.selectedColor]);
        }
    }

    selectColor(code) {
        this.selectedColor = code;
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('onclick').includes(`'${code}'`)) {
                btn.classList.add('active');
            }
        });
    }

    // --- 核心功能：读取状态并求解 (完美修正版) ---
    
    getCubeStateString() {
        // This version explicitly iterates through the grid of each face instead of sorting.
        // This guarantees the reading order is correct regardless of float rounding quirks.

        // Face Reading Order Definition:
        // U (Up):    y=1.  Z: -1, 0, 1 (Back->Front). X: -1, 0, 1 (Left->Right).
        // R (Right): x=1.  Y: 1, 0, -1 (Top->Bottom). Z: 1, 0, -1 (Front->Back).
        // F (Front): z=1.  Y: 1, 0, -1 (Top->Bottom). X: -1, 0, 1 (Left->Right).
        // D (Down):  y=-1. Z: 1, 0, -1 (Front->Back). X: -1, 0, 1 (Left->Right).
        // L (Left):  x=-1. Y: 1, 0, -1 (Top->Bottom). Z: -1, 0, 1 (Back->Front).
        // B (Back):  z=-1. Y: 1, 0, -1 (Top->Bottom). X: 1, 0, -1 (Right->Left).

        // Define scan loops for each face
        const scans = [
            { name: 'U', normal: new THREE.Vector3(0, 1, 0),  y: 1,  zLoop: [-1, 0, 1], xLoop: [-1, 0, 1] },
            { name: 'R', normal: new THREE.Vector3(1, 0, 0),  x: 1,  yLoop: [1, 0, -1], zLoop: [1, 0, -1] },
            { name: 'F', normal: new THREE.Vector3(0, 0, 1),  z: 1,  yLoop: [1, 0, -1], xLoop: [-1, 0, 1] },
            { name: 'D', normal: new THREE.Vector3(0, -1, 0), y: -1, zLoop: [1, 0, -1], xLoop: [-1, 0, 1] },
            { name: 'L', normal: new THREE.Vector3(-1, 0, 0), x: -1, yLoop: [1, 0, -1], zLoop: [-1, 0, 1] },
            { name: 'B', normal: new THREE.Vector3(0, 0, -1), z: -1, yLoop: [1, 0, -1], xLoop: [1, 0, -1] }
        ];

        // Material normals (local space)
        const localNormals = [
            new THREE.Vector3(1, 0, 0), // 0: Right
            new THREE.Vector3(-1, 0, 0), // 1: Left
            new THREE.Vector3(0, 1, 0), // 2: Top
            new THREE.Vector3(0, -1, 0), // 3: Bottom
            new THREE.Vector3(0, 0, 1), // 4: Front
            new THREE.Vector3(0, 0, -1) // 5: Back
        ];

        let fullString = "";

        for (let scan of scans) {
            let outerLoop = scan.yLoop || scan.zLoop || scan.xLoop; // Pick the one that isn't fixed
            // If scan.y is fixed, then outer is zLoop (for U/D) or yLoop (impossible).
            // Wait. We need nested loops.
            
            // Explicit loops based on face type
            let positions = [];
            if (scan.name === 'U' || scan.name === 'D') {
                // U/D: Outer Z, Inner X
                for (let z of scan.zLoop) {
                    for (let x of scan.xLoop) {
                        positions.push({x: x, y: scan.y, z: z});
                    }
                }
            } else if (scan.name === 'F' || scan.name === 'B') {
                // F/B: Outer Y, Inner X
                for (let y of scan.yLoop) {
                    for (let x of scan.xLoop) {
                        positions.push({x: x, y: y, z: scan.z});
                    }
                }
            } else if (scan.name === 'R' || scan.name === 'L') {
                // R/L: Outer Y, Inner Z
                for (let y of scan.yLoop) {
                    for (let z of scan.zLoop) {
                        positions.push({x: scan.x, y: y, z: z});
                    }
                }
            }

            // Now find the cubie at each position and read color
            for (let pos of positions) {
                let foundColor = '?';
                
                // Find cubie close to this position
                for (let mesh of this.cubies) {
                    if (Math.round(mesh.position.x) === pos.x &&
                        Math.round(mesh.position.y) === pos.y &&
                        Math.round(mesh.position.z) === pos.z) {
                        
                        // Found the cubie! Now find which face points to scan.normal
                        for(let i=0; i<6; i++) {
                            const worldNormal = localNormals[i].clone().applyQuaternion(mesh.quaternion);
                            if(worldNormal.dot(scan.normal) > 0.8) { 
                                const colorHex = mesh.material[i].color.getHex();
                                foundColor = this.hexToChar[colorHex] || '?';
                                break;
                            }
                        }
                        break; // Stop looking for cubie
                    }
                }
                fullString += foundColor;
            }
        }
        return fullString;
    }

    // Helper to normalize color scheme based on centers
    normalizeFacelets(rawString) {
        // Indices of centers in the string: 4, 13, 22, 31, 40, 49
        // U R F D L B
        const centerIndices = { 'U': 4, 'R': 13, 'F': 22, 'D': 31, 'L': 40, 'B': 49 };
        const map = {};
        const usedColors = new Set();

        // Find what color is at each center
        for (let face in centerIndices) {
            const idx = centerIndices[face];
            const colorChar = rawString[idx]; // e.g. 'R'
            map[colorChar] = face; // Map Red -> 'U' (if Red is at U center)
            usedColors.add(colorChar);
        }

        if (usedColors.size !== 6) {
            return { error: "中心块颜色重复或无效，请确保6个面中心颜色各不相同。" };
        }

        // Translate the string
        let normalized = "";
        for (let char of rawString) {
            if (map[char]) {
                normalized += map[char];
            } else {
                return { error: "发现未知颜色方块。" };
            }
        }
        
        return { result: normalized };
    }
    
    // 验证颜色数量
    validateState(stateStr) {
        const counts = { 'U':0, 'D':0, 'F':0, 'B':0, 'L':0, 'R':0, '?':0 };
        for(let char of stateStr) {
            if(counts[char] !== undefined) counts[char]++;
        }
        
        let errors = [];
        const names = { 'U':'白', 'D':'黄', 'F':'绿', 'B':'蓝', 'L':'橙', 'R':'红' };
        
        for(let key in names) {
            if (counts[key] !== 9) {
                let diff = counts[key] - 9;
                let msg = `${names[key]}色有 ${counts[key]} 个 (${diff > 0 ? '多' : '少'} ${Math.abs(diff)} 个)`;
                errors.push(msg);
            }
        }
        
        if(counts['?'] > 0) {
            errors.push(`还有 ${counts['?']} 个未填色方块`);
        }

        if(errors.length > 0) {
            // Improvement: Add specific advice
            let advice = "每个颜色必须正好 9 个。\n\n";
            advice += "💡 常见原因：\n";
            advice += "1. 您可能只涂了魔方的 3 个面，**背面和底面**还是默认颜色。\n";
            advice += "   请旋转视角（拖动背景），将魔方后方、下方也涂成和您手中魔方一致。\n";
            advice += "2. 颜色填错位置（如角块颜色冲突）。";
            
            return "颜色数量错误：\n" + errors.join("\n") + "\n\n" + advice;
        }
        return null; // Valid
    }

    showModal(msg) {
        document.getElementById('error-msg').innerText = msg;
        document.getElementById('error-modal').classList.add('active');
    }
    
    closeModal() {
        document.getElementById('error-modal').classList.remove('active');
    }

    async startSolveMode() {
        const stateString = this.getCubeStateString();
        console.log("Detected State (Raw):", stateString);
        
        // Step 1: Pre-validation of counts
        const validationError = this.validateState(stateString);
        if (validationError) {
            this.showModal(validationError);
            return;
        }

        // Step 2: Normalize based on centers (Fixes 'Error 1' due to rotation)
        const normResult = this.normalizeFacelets(stateString);
        if (normResult.error) {
             this.showModal(normResult.error);
             return;
        }
        const normalizedState = normResult.result;
        console.log("Normalized State:", normalizedState);

        this.showMessage("正在计算...", 0);

        setTimeout(async () => {
            try {
                // Pass NORMALIZED string to solver
                const solution = await this.solveWithAlgorithm(normalizedState);
                
                if (!solution) return;

                this.parseSolution(solution);
                
                document.getElementById('edit-controls').classList.add('hidden');
                document.getElementById('edit-controls').classList.remove('flex');
                document.getElementById('solve-controls').classList.remove('hidden');
                document.getElementById('step-display').classList.remove('hidden');
                document.getElementById('step-display').classList.add('flex');
                this.updateStepUI();
                this.showMessage("计算完成！");

            } catch (e) {
                if (e === "Solved") {
                    this.showModal("恭喜！魔方已经是还原状态！");
                    this.showMessage("已还原", 2000);
                    return;
                }

                console.error(e);
                let errorStr = String(e);
                let errMsg = "无法求解。\n\n";
                
                // min2phase specific error mapping
                if (errorStr.includes("Error 1")) errMsg += "中心块颜色不匹配，或者颜色数量不对。";
                else if (errorStr.includes("Error 2")) errMsg += "缺少 12 个棱块（物理状态不可能）。";
                else if (errorStr.includes("Error 3")) errMsg += "棱块翻转错误（物理状态不可能）。";
                else if (errorStr.includes("Error 4")) errMsg += "缺少 8 个角块（物理状态不可能）。";
                else if (errorStr.includes("Error 5")) errMsg += "角块扭转错误（物理状态不可能）。";
                else if (errorStr.includes("Error 6")) errMsg += "奇偶性错误（需要交换一对块）。";
                else if (errorStr.includes("Error 7")) errMsg += "求解超时，请重试或打乱重填。";
                else if (errorStr.includes("Error 8")) errMsg += "求解超时，请重试。";
                else errMsg += "原因可能是填色错误。请检查是否有相邻块颜色相同等情况。";

                this.showModal(errMsg);
                this.showMessage("错误", 2000);
            }
        }, 100);
    }

    solveWithAlgorithm(stateString) {
        return new Promise((resolve, reject) => {
            // Check if solved (UU.. RR.. FF.. etc)
            // Construct solved string based on center mapping? 
            // Actually, if normalized, solved state is U...R...F...D...L...B...
            const solvedStr = "UUUUUUUUURRRRRRRRRFFFFFFFFFDDDDDDDDDLLLLLLLLLBBBBBBBBB";
            if (stateString === solvedStr) {
                reject("Solved");
                return;
            }

            if (typeof min2phase === 'undefined' || !this.isSolverReady) {
                 if (this.scrambleHistory && this.scrambleHistory.length > 0) {
                     const moves = [...this.scrambleHistory].reverse().map(m => {
                        let notation = m.face;
                        if (m.dir === 1) notation += "'";
                        return notation;
                     }).join(" ");
                     resolve(moves);
                     this.scrambleHistory = [];
                     return;
                 }
                 
                 reject("Library missing");
                 return;
            }

            try {
                var solution = min2phase.solve(stateString);
                if (solution && solution.length > 0 && !solution.startsWith("Error")) {
                    resolve(solution);
                } else {
                    reject("Solver returned error: " + solution);
                }
            } catch (err) {
                reject(err);
            }
        });
    }

    parseSolution(solStr) {
        const moves = solStr.trim().split(/\s+/);
        this.solutionQueue = moves.map(m => {
            if(!m) return null; 
            let face = m[0];
            let dir = 1;
            let power = 1;
            if (m.includes("'")) { dir = -1; power = -1; }
            if (m.includes("2")) { power = 2; }
            return { face, power, notation: m };
        }).filter(m => m !== null);
        
        this.currentStepIndex = -1;
    }

    // --- 动画与逻辑 ---

    rotateFace(face, power = 1, duration = 300) {
        return new Promise((resolve) => {
            this.isAnimating = true;
            
            const rotations = Math.abs(power);
            const dir = power > 0 ? 1 : -1;
            const singleDuration = duration / rotations;

            let count = 0;
            const run = () => {
                this._rotateSingle90(face, dir, singleDuration).then(() => {
                    count++;
                    if (count < rotations) {
                        run();
                    } else {
                        this.isAnimating = false;
                        resolve();
                    }
                });
            };
            run();
        });
    }

    _rotateSingle90(face, direction, duration) {
        return new Promise((resolve) => {
            let axis = new THREE.Vector3();
            let cubiesToRotate = [];
            const EPSILON = 0.1;

            this.cubies.forEach(cubie => {
                const pos = cubie.position;
                if (face === 'U' && Math.abs(pos.y - 1) < EPSILON) { axis = this.axes.y; cubiesToRotate.push(cubie); }
                if (face === 'D' && Math.abs(pos.y + 1) < EPSILON) { axis = this.axes.y; cubiesToRotate.push(cubie); }
                if (face === 'R' && Math.abs(pos.x - 1) < EPSILON) { axis = this.axes.x; cubiesToRotate.push(cubie); }
                if (face === 'L' && Math.abs(pos.x + 1) < EPSILON) { axis = this.axes.x; cubiesToRotate.push(cubie); }
                if (face === 'F' && Math.abs(pos.z - 1) < EPSILON) { axis = this.axes.z; cubiesToRotate.push(cubie); }
                if (face === 'B' && Math.abs(pos.z + 1) < EPSILON) { axis = this.axes.z; cubiesToRotate.push(cubie); }
            });

            let angle = (Math.PI / 2) * -direction;
            if (face === 'L' || face === 'B') angle = (Math.PI / 2) * direction; 

            const pivot = new THREE.Object3D();
            pivot.rotation.set(0,0,0);
            this.scene.add(pivot);
            cubiesToRotate.forEach(c => { this.scene.remove(c); pivot.add(c); });

            new TWEEN.Tween(pivot.rotation)
                .to({ [axis.x ? 'x' : axis.y ? 'y' : 'z']: angle }, duration)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    pivot.updateMatrixWorld();
                    cubiesToRotate.forEach(c => {
                        c.updateMatrixWorld();
                        const vector = new THREE.Vector3();
                        const quaternion = new THREE.Quaternion();
                        c.getWorldPosition(vector);
                        c.getWorldQuaternion(quaternion);
                        vector.x = Math.round(vector.x);
                        vector.y = Math.round(vector.y);
                        vector.z = Math.round(vector.z);
                        c.position.copy(vector);
                        c.quaternion.copy(quaternion);
                        pivot.remove(c);
                        this.scene.add(c);
                    });
                    this.scene.remove(pivot);
                    resolve();
                })
                .start();
        });
    }

    async scramble() {
        if (this.isAnimating) return;
        this.showMessage("正在打乱...");
        this.scrambleHistory = []; 
        
        const faces = ['U', 'D', 'L', 'R', 'F', 'B'];
        for (let i = 0; i < 15; i++) {
            const face = faces[Math.floor(Math.random() * faces.length)];
            const dir = Math.random() > 0.5 ? 1 : -1;
            await this.rotateFace(face, dir, 100);
            this.scrambleHistory.push({ face, dir });
        }
        this.showMessage("打乱完成");
    }

    // --- Step Logic ---

    updateStepUI() {
        const total = this.solutionQueue.length;
        const current = this.currentStepIndex + 1;
        document.getElementById('step-counter').innerText = `${current} / ${total}`;
        const pct = total === 0 ? 0 : (current / total) * 100;
        document.getElementById('progress-bar').style.width = `${pct}%`;

        if (this.currentStepIndex >= 0 && this.currentStepIndex < total) {
            document.getElementById('current-move-text').innerText = this.solutionQueue[this.currentStepIndex].notation;
        } else if (this.currentStepIndex === -1) {
            document.getElementById('current-move-text').innerText = "Ready";
        } else {
            document.getElementById('current-move-text').innerText = "Done";
        }

        document.getElementById('btn-prev').disabled = (this.currentStepIndex < 0);
        document.getElementById('btn-next').disabled = (this.currentStepIndex >= total - 1);
    }

    async nextStep() {
        if (this.isAnimating) return;
        if (this.currentStepIndex >= this.solutionQueue.length - 1) {
            this.showMessage("已完成还原！");
            this.stopAutoPlay();
            return;
        }
        const nextIdx = this.currentStepIndex + 1;
        const move = this.solutionQueue[nextIdx];
        this.currentStepIndex = nextIdx; 
        this.updateStepUI();
        await this.rotateFace(move.face, move.power, 400);
    }

    async prevStep() {
        if (this.isAnimating) return;
        if (this.currentStepIndex < 0) return;
        const move = this.solutionQueue[this.currentStepIndex];
        // Undo: Inverse power
        this.currentStepIndex--;
        this.updateStepUI();
        await this.rotateFace(move.face, -move.power, 400);
    }

    toggleAutoPlay() {
        if (this.isPlaying) this.stopAutoPlay();
        else this.startAutoPlay();
    }

    startAutoPlay() {
        if (this.currentStepIndex >= this.solutionQueue.length - 1) return;
        this.isPlaying = true;
        document.getElementById('play-text').innerText = "暂停";
        const stepLoop = async () => {
            if (!this.isPlaying) return;
            if (this.currentStepIndex >= this.solutionQueue.length - 1) {
                this.stopAutoPlay();
                return;
            }
            await this.nextStep();
            if (this.isPlaying) setTimeout(stepLoop, 200);
        };
        stepLoop();
    }

    stopAutoPlay() {
        this.isPlaying = false;
        document.getElementById('play-text').innerText = "播放";
    }

    // --- Helper ---
    showMessage(text, time = 2000) {
        const el = document.getElementById('msg-box');
        el.innerText = text;
        el.classList.add('show');
        if (this.msgTimeout) clearTimeout(this.msgTimeout);
        if (time > 0) {
            this.msgTimeout = setTimeout(() => { el.classList.remove('show'); }, time);
        }
    }
    highlightFace(mesh) {
        new TWEEN.Tween(mesh.scale).to({ x: 0.8, y: 0.8, z: 0.8 }, 50).yoyo(true).repeat(1).start();
    }
    resetCamera() {
        new TWEEN.Tween(this.camera.position).to({ x: 6, y: 5, z: 8 }, 1000).easing(TWEEN.Easing.Cubic.Out).onUpdate(() => this.camera.lookAt(0,0,0)).start();
    }
    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    animate() {
        requestAnimationFrame(() => this.animate());
        TWEEN.update();
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }
}

window.onload = () => { window.app = new RubiksApp(); };
</script>
</body>
</html>