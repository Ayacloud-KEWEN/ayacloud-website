<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <title>è‡ªåŠ¨è¯†åˆ«é™„è¿‘åœ°æ ‡ + AIè®²è§£ï¼ˆWebARï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <!-- A-Frame + AR.js -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar-nft.js"></script>
  <style>
    body,html{margin:0;height:100%;background:#000;overflow:hidden}
    #ui {
      position: absolute; left: 8px; top: 8px; z-index: 999;
      color: #fff; font-family: system-ui, sans-serif;
      background: rgba(0,0,0,0.45); padding: 8px; border-radius: 8px;
      max-width: calc(100% - 16px);
    }
    #poi-list { max-height: 180px; overflow:auto; margin-top:8px; font-size:14px; }
    button { margin-right:6px; }
    #info-box {
      position: absolute; bottom: 14px; left:50%; transform:translateX(-50%);
      background: rgba(0,0,0,0.7); color:#fff; padding:10px 14px; border-radius:10px;
      font-family: system-ui, sans-serif; font-size:15px; max-width:92%;
      text-align:center;
    }
    #loading {
      position: fixed; inset:0; display:flex; align-items:center; justify-content:center;
      color:#fff; font-size:18px; z-index:9999; background: linear-gradient(180deg, rgba(0,0,0,0.8), rgba(0,0,0,0.4));
    }
  </style>
</head>
<body>
  <div id="loading">ğŸ“ è·å–ä½ç½®ä¸å‘¨è¾¹åœ°æ ‡ä¸­â€¦â€¦ï¼ˆå…è®¸å®šä½ä¸æ‘„åƒå¤´ï¼‰</div>

  <div id="ui">
    <div><strong>è‡ªåŠ¨å‘¨è¾¹åœ°æ ‡ + AIè®²è§£ï¼ˆæµ‹è¯•ç‰ˆï¼‰</strong></div>
    <div style="margin-top:6px; font-size:13px;">
      åŠå¾„ï¼ˆmï¼‰ï¼š <input id="radius" type="number" value="800" style="width:80px" /> 
      <button id="refreshBtn">åˆ·æ–°é™„è¿‘åœ°æ ‡</button>
      <button id="toggleNames">æ˜¾ç¤º/éšè—åç§°</button>
    </div>
    <div id="poi-list"></div>
  </div>

  <div id="info-box">å¯¹å‡†åœ°æ ‡æˆ–ç‚¹å‡»åˆ—è¡¨é¡¹ä»¥æ’­æ”¾è®²è§£ã€‚</div>

  <a-scene vr-mode-ui="enabled: false" embedded arjs="sourceType: webcam; debugUIEnabled: false; gpsMinDistance: 3;">
    <!-- åŠ¨æ€æ³¨å…¥ POI å®ä½“ -->
    <a-camera gps-camera rotation-reader></a-camera>
  </a-scene>

<script>
/* ----------------- é…ç½® ----------------- */
/*
  OpenAI Keyï¼ˆå¯é€‰ï¼‰ï¼š
  - è‹¥å¡«å…¥ï¼Œé¡µé¢ä¼šç›´æ¥ä»æµè§ˆå™¨è°ƒç”¨ OpenAI Chat APIï¼ˆä»…ä¾›æµ‹è¯•ï¼‰ã€‚
  - ä¸Šçº¿è¯·ä¸è¦åœ¨å‰ç«¯ä¿å­˜ Keyï¼Œæ”¹ä¸ºåç«¯ä»£ç†è¯·æ±‚ã€‚
*/
const OPENAI_API_KEY = ""; // <-- å¦‚æœä½ æœ‰ keyï¼Œå¡«åœ¨è¿™é‡Œï¼ˆæµ‹è¯•ç”¨ï¼‰ã€‚å¦åˆ™ç•™ç©ºä½¿ç”¨ Wikipedia å›é€€ã€‚

/* Overpass é…ç½® */
const OVERPASS_ENDPOINT = "https://overpass-api.de/api/interpreter";

/* ä¸€äº›è¿è¡Œæ—¶å˜é‡ */
let userLat = null, userLon = null;
let poiEntities = []; // track created entities
let showingNames = true;

/* å·¥å…·ï¼šè®¡ç®—ä¸¤ç‚¹è·ç¦»ï¼ˆç±³ï¼‰ */
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const toRad = v => v * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/* è·å–é™„è¿‘ POIï¼ˆOverpassï¼‰ */
async function fetchNearbyPOIs(lat, lon, radiusMeters=800) {
  // æŸ¥è¯¢å¸¸è§å¯ä½œä¸ºâ€œåœ°æ ‡â€çš„æ ‡ç­¾ï¼ˆtourism,historic,amenity,place,shopï¼‰
  const q = `
[out:json][timeout:25];
(
  node(around:${radiusMeters},${lat},${lon})[~"^(tourism|historic|amenity|place|shop)$"~"."]; 
  way(around:${radiusMeters},${lat},${lon})[~"^(tourism|historic|amenity|place|shop)$"~"."]; 
  relation(around:${radiusMeters},${lat},${lon})[~"^(tourism|historic|amenity|place|shop)$"~"."];
);
out center;`;
  const resp = await fetch(OVERPASS_ENDPOINT, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
    body: "data=" + encodeURIComponent(q)
  });
  if(!resp.ok) throw new Error("Overpass è¯·æ±‚å¤±è´¥: " + resp.status);
  const json = await resp.json();
  const elems = json.elements || [];
  const pois = [];
  for(const el of elems) {
    const tags = el.tags || {};
    if(!tags.name) continue; // éœ€è¦åå­—
    let plat = el.lat, plon = el.lon;
    if(!plat && el.center) { plat = el.center.lat; plon = el.center.lon; }
    if(!plat) continue;
    const dist = haversineDistance(lat, lon, plat, plon);
    pois.push({
      id: el.id,
      name: tags.name,
      lat: plat,
      lon: plon,
      tags,
      dist
    });
  }
  // æŒ‰è·ç¦»æ’åºå¹¶å»é‡ï¼ˆåŒåï¼‰
  const byName = {};
  const filtered = [];
  pois.sort((a,b)=>a.dist - b.dist);
  for(const p of pois) {
    if(!byName[p.name]) { filtered.push(p); byName[p.name]=true; }
  }
  return filtered.slice(0, 30); // æœ€å¤š30ä¸ª
}

/* åœ¨ARåœºæ™¯ä¸­æ¸²æŸ“POI */
function renderPOIs(pois) {
  // ç§»é™¤æ—§çš„ poi
  const scene = document.querySelector('a-scene');
  // remove previous entities
  poiEntities.forEach(e => { try{ scene.removeChild(e) }catch(e){} });
  poiEntities = [];

  const listEl = document.getElementById('poi-list');
  listEl.innerHTML = "";

  pois.forEach((p, idx) => {
    // create entity
    const ent = document.createElement('a-entity');
    ent.setAttribute('gps-entity-place', `latitude: ${p.lat}; longitude: ${p.lon};`);
    ent.setAttribute('scale', '18 18 18');
    ent.setAttribute('look-at', '[gps-camera]');
    ent.classList.add('poi-entity');
    ent.dataset.name = p.name;
    ent.dataset.idx = idx;

    // label text (toggle show/hide)
    const txt = document.createElement('a-text');
    txt.setAttribute('value', `${p.name}\n${Math.round(p.dist)} m`);
    txt.setAttribute('align','center');
    txt.setAttribute('position','0 2 0');
    txt.setAttribute('color', '#FFD700');
    ent.appendChild(txt);

    const sphere = document.createElement('a-sphere');
    sphere.setAttribute('radius','0.5');
    sphere.setAttribute('opacity','0.6');
    sphere.setAttribute('position','0 0 0');
    sphere.setAttribute('color','#FF8C00');
    ent.appendChild(sphere);

    // click handler
    ent.addEventListener('click', async (ev) => {
      const name = ent.dataset.name;
      showInfo(`ğŸ¤– ç”Ÿæˆ ${name} çš„è®²è§£â€¦â€¦`);
      try {
        const text = await getAIExplanation(name);
        showInfo(`ğŸ§ ${text}`);
        speakText(text);
      } catch(err) {
        console.error(err);
        showInfo('âš ï¸ è·å–è®²è§£å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–ç¨åé‡è¯•ã€‚');
      }
    });

    scene.appendChild(ent);
    poiEntities.push(ent);

    // add to list UI
    const row = document.createElement('div');
    row.style.padding = '6px 0';
    row.style.borderBottom = '1px solid rgba(255,255,255,0.06)';
    row.innerHTML = `<strong>${p.name}</strong> Â· ${Math.round(p.dist)} m 
      <button data-idx="${idx}">æ’­æ”¾è®²è§£</button>`;
    listEl.appendChild(row);

    row.querySelector('button').addEventListener('click', async () => {
      showInfo(`ğŸ¤– ç”Ÿæˆ ${p.name} çš„è®²è§£â€¦â€¦`);
      try {
        const text = await getAIExplanation(p.name);
        showInfo(`ğŸ§ ${text}`);
        speakText(text);
      } catch(err) {
        console.error(err);
        showInfo('âš ï¸ è·å–è®²è§£å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–ç¨åé‡è¯•ã€‚');
      }
    });
  });
}

/* æ˜¾ç¤ºæ¶ˆæ¯ */
function showInfo(msg) {
  document.getElementById('info-box').innerText = msg;
}

/* TTS */
function speakText(text) {
  if('speechSynthesis' in window) {
    const u = new SpeechSynthesisUtterance(text);
    // å°è¯•è®¾å®šè¯­è¨€ä¸ºä¸­æ–‡ï¼Œå¦‚æœæµè§ˆå™¨ä¸æ”¯æŒä¼šå›è½
    u.lang = 'zh-CN';
    u.rate = 1.0;
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(u);
  } else {
    alert('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆï¼ˆSpeechSynthesisï¼‰ã€‚');
  }
}

/* AI è®²è§£æŠ½è±¡ï¼šä¼˜å…ˆ OpenAIï¼ˆè‹¥æœ‰KEYï¼‰ï¼Œå¦åˆ™ Wikipedia æ‘˜è¦å›é€€ï¼Œå†å¦åˆ™æ¨¡æ¿ */
async function getAIExplanation(placeName) {
  // 1) è‹¥æœ‰ OPENAI_API_KEY ä¸”æœ‰ç½‘ç»œï¼Œè°ƒç”¨ OpenAI Chat å®Œæˆ
  if(OPENAI_API_KEY && OPENAI_API_KEY.trim().length > 8) {
    // ç®€çŸ­ prompt æ§åˆ¶ 60s å†…
    const prompt = `è¯·ç”¨ç®€çŸ­ã€ç”ŸåŠ¨çš„ä¸­æ–‡ä¸º"${placeName}"ç”Ÿæˆä¸€æ®µ60ç§’å†…çš„è¯­éŸ³å¯¼è§ˆè®²è§£ï¼Œè¯­æ°”å‹å¥½ã€ä¿¡æ¯åŒ…æ‹¬å†å²/çœ‹ç‚¹/è¶£é—»ä¸­çš„ä¸€ä¸¤ç‚¹ã€‚`;
    const payload = {
      model: "gpt-4o-mini",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.7,
    };
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type":"application/json",
        "Authorization": `Bearer ${OPENAI_API_KEY}`
      },
      body: JSON.stringify(payload)
    });
    if(!resp.ok) {
      const txt = await resp.text();
      throw new Error("OpenAI error: " + resp.status + " / " + txt);
    }
    const j = await resp.json();
    const text = j.choices?.[0]?.message?.content;
    if(text) return text.trim();
  }

  // 2) å°è¯• Wikipedia æ‘˜è¦ï¼ˆä¼˜å…ˆä¸­æ–‡ç»´åŸºï¼Œå†è‹±æ–‡ç»´åŸºï¼‰
  try {
    // encode title for zh first
    const zhTitle = encodeURIComponent(placeName);
    let wikiResp = await fetch(`https://zh.wikipedia.org/api/rest_v1/page/summary/${zhTitle}`);
    if(!wikiResp.ok) {
      // try english
      const enTitle = encodeURIComponent(placeName);
      wikiResp = await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${enTitle}`);
    }
    if(wikiResp.ok) {
      const data = await wikiResp.json();
      if(data.extract) {
        // keep it brief: take first 2 sentences if too long
        const s = data.extract;
        const sentences = s.match(/[^\.!\?ã€‚ï¼ï¼Ÿ]+[\.!\?ã€‚ï¼ï¼Ÿ]?/g) || [s];
        const brief = sentences.slice(0,2).join('').trim();
        return brief;
      }
    }
  } catch(e) {
    console.warn('Wikipedia fetch failed', e);
  }

  // 3) å›é€€æ¨¡æ¿
  return `${placeName} æ˜¯é™„è¿‘çš„ä¸€ä¸ªæœ‰è¶£åœ°ç‚¹ã€‚è¿™é‡Œæœ‰ä¸°å¯Œçš„å†å²ä¸å½“åœ°æ•…äº‹ï¼šä¾‹å¦‚å®ƒå¸¸è¢«äººä»¬æåˆ°çš„ç‰¹ç‚¹åŒ…æ‹¬å†å²ã€å»ºç­‘æˆ–æ–‡åŒ–ä»·å€¼ã€‚åˆ°ç°åœºå¯ä»¥æ³¨æ„è§‚å¯Ÿå»ºç­‘ç»†èŠ‚ä¸å‘¨è¾¹ç¯å¢ƒã€‚`;
}

/* åˆå§‹æµç¨‹ï¼šè·å–å®šä½ -> æŸ¥è¯¢ POI -> æ¸²æŸ“ */
async function init() {
  try {
    // get position
    const pos = await new Promise((resolve, reject) => {
      if(!navigator.geolocation) return reject(new Error("æµè§ˆå™¨ä¸æ”¯æŒ Geolocation"));
      navigator.geolocation.getCurrentPosition(resolve, reject, { enableHighAccuracy: true, maximumAge: 0, timeout: 20000 });
    });
    userLat = pos.coords.latitude;
    userLon = pos.coords.longitude;
    console.log("å®šä½ï¼š", userLat, userLon);
    // fetch POIs
    const radius = parseInt(document.getElementById('radius').value) || 800;
    showInfo('ğŸ” æ­£åœ¨æ£€ç´¢é™„è¿‘åœ°æ ‡ï¼ˆOverpassï¼‰â€¦â€¦');
    const pois = await fetchNearbyPOIs(userLat, userLon, radius);
    if(pois.length === 0) {
      showInfo('æœªå‘ç°å‘¨è¾¹æ˜¾è‘—åœ°æ ‡ï¼ˆå°è¯•å¢å¤§åŠå¾„æˆ–æ‰‹åŠ¨æ·»åŠ ï¼‰ã€‚');
    } else {
      showInfo(`æ‰¾åˆ° ${pois.length} ä¸ªé™„è¿‘åœ°æ ‡ï¼Œç‚¹å‡»å³å¯å¬è®²è§£ã€‚`);
      renderPOIs(pois);
    }
  } catch(err) {
    console.error(err);
    showInfo('âš ï¸ æ— æ³•è·å–å®šä½æˆ–æ£€ç´¢åœ°æ ‡ï¼š' + (err.message||err));
  } finally {
    document.getElementById('loading').style.display = 'none';
  }
}

/* UI äº‹ä»¶ç»‘å®š */
document.getElementById('refreshBtn').addEventListener('click', () => {
  document.getElementById('loading').style.display = 'flex';
  init();
});
document.getElementById('toggleNames').addEventListener('click', () => {
  showingNames = !showingNames;
  poiEntities.forEach(ent => {
    const txt = ent.querySelector('a-text');
    if(txt) txt.setAttribute('visible', showingNames ? 'true' : 'false');
  });
});

/* å¯åŠ¨ */
init();
</script>

</body>
</html>
